"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/diff-match-patch";
exports.ids = ["vendor-chunks/diff-match-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/diff-match-patch/index.js":
/*!************************************************!*\
  !*** ./node_modules/diff-match-patch/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */ /**\n * Class containing the diff, match and patch methods.\n * @constructor\n */ \nvar diff_match_patch = function() {\n    // Defaults.\n    // Redefine these in your program to override the defaults.\n    // Number of seconds to map a diff before giving up (0 for infinity).\n    this.Diff_Timeout = 1.0;\n    // Cost of an empty edit operation in terms of edit characters.\n    this.Diff_EditCost = 4;\n    // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n    this.Match_Threshold = 0.5;\n    // How far to search for a match (0 = exact location, 1000+ = broad match).\n    // A match this many characters away from the expected location will add\n    // 1.0 to the score (0.0 is a perfect match).\n    this.Match_Distance = 1000;\n    // When deleting a large block of text (over ~64 characters), how close do\n    // the contents have to be to match the expected contents. (0.0 = perfection,\n    // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n    // end points of a delete need to match.\n    this.Patch_DeleteThreshold = 0.5;\n    // Chunk size for context length.\n    this.Patch_Margin = 4;\n    // The number of bits in an int.\n    this.Match_MaxBits = 32;\n};\n//  DIFF FUNCTIONS\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */ var DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */ diff_match_patch.Diff = function(op, text) {\n    return [\n        op,\n        text\n    ];\n};\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */ diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {\n    // Set a deadline by which time the diff must be complete.\n    if (typeof opt_deadline == \"undefined\") {\n        if (this.Diff_Timeout <= 0) {\n            opt_deadline = Number.MAX_VALUE;\n        } else {\n            opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n        }\n    }\n    var deadline = opt_deadline;\n    // Check for null inputs.\n    if (text1 == null || text2 == null) {\n        throw new Error(\"Null input. (diff_main)\");\n    }\n    // Check for equality (speedup).\n    if (text1 == text2) {\n        if (text1) {\n            return [\n                new diff_match_patch.Diff(DIFF_EQUAL, text1)\n            ];\n        }\n        return [];\n    }\n    if (typeof opt_checklines == \"undefined\") {\n        opt_checklines = true;\n    }\n    var checklines = opt_checklines;\n    // Trim off common prefix (speedup).\n    var commonlength = this.diff_commonPrefix(text1, text2);\n    var commonprefix = text1.substring(0, commonlength);\n    text1 = text1.substring(commonlength);\n    text2 = text2.substring(commonlength);\n    // Trim off common suffix (speedup).\n    commonlength = this.diff_commonSuffix(text1, text2);\n    var commonsuffix = text1.substring(text1.length - commonlength);\n    text1 = text1.substring(0, text1.length - commonlength);\n    text2 = text2.substring(0, text2.length - commonlength);\n    // Compute the diff on the middle block.\n    var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n    // Restore the prefix and suffix.\n    if (commonprefix) {\n        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n    }\n    if (commonsuffix) {\n        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n    }\n    this.diff_cleanupMerge(diffs);\n    return diffs;\n};\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */ diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {\n    var diffs;\n    if (!text1) {\n        // Just add some text (speedup).\n        return [\n            new diff_match_patch.Diff(DIFF_INSERT, text2)\n        ];\n    }\n    if (!text2) {\n        // Just delete some text (speedup).\n        return [\n            new diff_match_patch.Diff(DIFF_DELETE, text1)\n        ];\n    }\n    var longtext = text1.length > text2.length ? text1 : text2;\n    var shorttext = text1.length > text2.length ? text2 : text1;\n    var i = longtext.indexOf(shorttext);\n    if (i != -1) {\n        // Shorter text is inside the longer text (speedup).\n        diffs = [\n            new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n            new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n            new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(i + shorttext.length))\n        ];\n        // Swap insertions for deletions if diff is reversed.\n        if (text1.length > text2.length) {\n            diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n        }\n        return diffs;\n    }\n    if (shorttext.length == 1) {\n        // Single character string.\n        // After the previous speedup, the character can't be an equality.\n        return [\n            new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)\n        ];\n    }\n    // Check to see if the problem can be split in two.\n    var hm = this.diff_halfMatch_(text1, text2);\n    if (hm) {\n        // A half-match was found, sort out the return data.\n        var text1_a = hm[0];\n        var text1_b = hm[1];\n        var text2_a = hm[2];\n        var text2_b = hm[3];\n        var mid_common = hm[4];\n        // Send both pairs off for separate processing.\n        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n        // Merge the results.\n        return diffs_a.concat([\n            new diff_match_patch.Diff(DIFF_EQUAL, mid_common)\n        ], diffs_b);\n    }\n    if (checklines && text1.length > 100 && text2.length > 100) {\n        return this.diff_lineMode_(text1, text2, deadline);\n    }\n    return this.diff_bisect_(text1, text2, deadline);\n};\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */ diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n    // Scan the text on a line-by-line basis first.\n    var a = this.diff_linesToChars_(text1, text2);\n    text1 = a.chars1;\n    text2 = a.chars2;\n    var linearray = a.lineArray;\n    var diffs = this.diff_main(text1, text2, false, deadline);\n    // Convert the diff back to original text.\n    this.diff_charsToLines_(diffs, linearray);\n    // Eliminate freak matches (e.g. blank lines)\n    this.diff_cleanupSemantic(diffs);\n    // Rediff any replacement blocks, this time character-by-character.\n    // Add a dummy entry at the end.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, \"\"));\n    var pointer = 0;\n    var count_delete = 0;\n    var count_insert = 0;\n    var text_delete = \"\";\n    var text_insert = \"\";\n    while(pointer < diffs.length){\n        switch(diffs[pointer][0]){\n            case DIFF_INSERT:\n                count_insert++;\n                text_insert += diffs[pointer][1];\n                break;\n            case DIFF_DELETE:\n                count_delete++;\n                text_delete += diffs[pointer][1];\n                break;\n            case DIFF_EQUAL:\n                // Upon reaching an equality, check for prior redundancies.\n                if (count_delete >= 1 && count_insert >= 1) {\n                    // Delete the offending records and add the merged ones.\n                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);\n                    pointer = pointer - count_delete - count_insert;\n                    var subDiff = this.diff_main(text_delete, text_insert, false, deadline);\n                    for(var j = subDiff.length - 1; j >= 0; j--){\n                        diffs.splice(pointer, 0, subDiff[j]);\n                    }\n                    pointer = pointer + subDiff.length;\n                }\n                count_insert = 0;\n                count_delete = 0;\n                text_delete = \"\";\n                text_insert = \"\";\n                break;\n        }\n        pointer++;\n    }\n    diffs.pop(); // Remove the dummy entry at the end.\n    return diffs;\n};\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */ diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n    // Cache the text lengths to prevent multiple calls.\n    var text1_length = text1.length;\n    var text2_length = text2.length;\n    var max_d = Math.ceil((text1_length + text2_length) / 2);\n    var v_offset = max_d;\n    var v_length = 2 * max_d;\n    var v1 = new Array(v_length);\n    var v2 = new Array(v_length);\n    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n    // integers and undefined.\n    for(var x = 0; x < v_length; x++){\n        v1[x] = -1;\n        v2[x] = -1;\n    }\n    v1[v_offset + 1] = 0;\n    v2[v_offset + 1] = 0;\n    var delta = text1_length - text2_length;\n    // If the total number of characters is odd, then the front path will collide\n    // with the reverse path.\n    var front = delta % 2 != 0;\n    // Offsets for start and end of k loop.\n    // Prevents mapping of space beyond the grid.\n    var k1start = 0;\n    var k1end = 0;\n    var k2start = 0;\n    var k2end = 0;\n    for(var d = 0; d < max_d; d++){\n        // Bail out if deadline is reached.\n        if (new Date().getTime() > deadline) {\n            break;\n        }\n        // Walk the front path one step.\n        for(var k1 = -d + k1start; k1 <= d - k1end; k1 += 2){\n            var k1_offset = v_offset + k1;\n            var x1;\n            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n                x1 = v1[k1_offset + 1];\n            } else {\n                x1 = v1[k1_offset - 1] + 1;\n            }\n            var y1 = x1 - k1;\n            while(x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)){\n                x1++;\n                y1++;\n            }\n            v1[k1_offset] = x1;\n            if (x1 > text1_length) {\n                // Ran off the right of the graph.\n                k1end += 2;\n            } else if (y1 > text2_length) {\n                // Ran off the bottom of the graph.\n                k1start += 2;\n            } else if (front) {\n                var k2_offset = v_offset + delta - k1;\n                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n                    // Mirror x2 onto top-left coordinate system.\n                    var x2 = text1_length - v2[k2_offset];\n                    if (x1 >= x2) {\n                        // Overlap detected.\n                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                    }\n                }\n            }\n        }\n        // Walk the reverse path one step.\n        for(var k2 = -d + k2start; k2 <= d - k2end; k2 += 2){\n            var k2_offset = v_offset + k2;\n            var x2;\n            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n                x2 = v2[k2_offset + 1];\n            } else {\n                x2 = v2[k2_offset - 1] + 1;\n            }\n            var y2 = x2 - k2;\n            while(x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)){\n                x2++;\n                y2++;\n            }\n            v2[k2_offset] = x2;\n            if (x2 > text1_length) {\n                // Ran off the left of the graph.\n                k2end += 2;\n            } else if (y2 > text2_length) {\n                // Ran off the top of the graph.\n                k2start += 2;\n            } else if (!front) {\n                var k1_offset = v_offset + delta - k2;\n                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n                    var x1 = v1[k1_offset];\n                    var y1 = v_offset + x1 - k1_offset;\n                    // Mirror x2 onto top-left coordinate system.\n                    x2 = text1_length - x2;\n                    if (x1 >= x2) {\n                        // Overlap detected.\n                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                    }\n                }\n            }\n        }\n    }\n    // Diff took too long and hit the deadline or\n    // number of diffs equals number of characters, no commonality at all.\n    return [\n        new diff_match_patch.Diff(DIFF_DELETE, text1),\n        new diff_match_patch.Diff(DIFF_INSERT, text2)\n    ];\n};\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */ diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {\n    var text1a = text1.substring(0, x);\n    var text2a = text2.substring(0, y);\n    var text1b = text1.substring(x);\n    var text2b = text2.substring(y);\n    // Compute both diffs serially.\n    var diffs = this.diff_main(text1a, text2a, false, deadline);\n    var diffsb = this.diff_main(text1b, text2b, false, deadline);\n    return diffs.concat(diffsb);\n};\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */ diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n    var lineArray = []; // e.g. lineArray[4] == 'Hello\\n'\n    var lineHash = {}; // e.g. lineHash['Hello\\n'] == 4\n    // '\\x00' is a valid character, but various debuggers don't like it.\n    // So we'll insert a junk entry to avoid generating a null character.\n    lineArray[0] = \"\";\n    /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */ function diff_linesToCharsMunge_(text) {\n        var chars = \"\";\n        // Walk the text, pulling out a substring for each line.\n        // text.split('\\n') would would temporarily double our memory footprint.\n        // Modifying text would create many large strings to garbage collect.\n        var lineStart = 0;\n        var lineEnd = -1;\n        // Keeping our own length variable is faster than looking it up.\n        var lineArrayLength = lineArray.length;\n        while(lineEnd < text.length - 1){\n            lineEnd = text.indexOf(\"\\n\", lineStart);\n            if (lineEnd == -1) {\n                lineEnd = text.length - 1;\n            }\n            var line = text.substring(lineStart, lineEnd + 1);\n            if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {\n                chars += String.fromCharCode(lineHash[line]);\n            } else {\n                if (lineArrayLength == maxLines) {\n                    // Bail out at 65535 because\n                    // String.fromCharCode(65536) == String.fromCharCode(0)\n                    line = text.substring(lineStart);\n                    lineEnd = text.length;\n                }\n                chars += String.fromCharCode(lineArrayLength);\n                lineHash[line] = lineArrayLength;\n                lineArray[lineArrayLength++] = line;\n            }\n            lineStart = lineEnd + 1;\n        }\n        return chars;\n    }\n    // Allocate 2/3rds of the space for text1, the rest for text2.\n    var maxLines = 40000;\n    var chars1 = diff_linesToCharsMunge_(text1);\n    maxLines = 65535;\n    var chars2 = diff_linesToCharsMunge_(text2);\n    return {\n        chars1: chars1,\n        chars2: chars2,\n        lineArray: lineArray\n    };\n};\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */ diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n    for(var i = 0; i < diffs.length; i++){\n        var chars = diffs[i][1];\n        var text = [];\n        for(var j = 0; j < chars.length; j++){\n            text[j] = lineArray[chars.charCodeAt(j)];\n        }\n        diffs[i][1] = text.join(\"\");\n    }\n};\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */ diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n        return 0;\n    }\n    // Binary search.\n    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n    var pointermin = 0;\n    var pointermax = Math.min(text1.length, text2.length);\n    var pointermid = pointermax;\n    var pointerstart = 0;\n    while(pointermin < pointermid){\n        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n            pointermin = pointermid;\n            pointerstart = pointermin;\n        } else {\n            pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n};\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */ diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n        return 0;\n    }\n    // Binary search.\n    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n    var pointermin = 0;\n    var pointermax = Math.min(text1.length, text2.length);\n    var pointermid = pointermax;\n    var pointerend = 0;\n    while(pointermin < pointermid){\n        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n            pointermin = pointermid;\n            pointerend = pointermin;\n        } else {\n            pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n};\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */ diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n    // Cache the text lengths to prevent multiple calls.\n    var text1_length = text1.length;\n    var text2_length = text2.length;\n    // Eliminate the null case.\n    if (text1_length == 0 || text2_length == 0) {\n        return 0;\n    }\n    // Truncate the longer string.\n    if (text1_length > text2_length) {\n        text1 = text1.substring(text1_length - text2_length);\n    } else if (text1_length < text2_length) {\n        text2 = text2.substring(0, text1_length);\n    }\n    var text_length = Math.min(text1_length, text2_length);\n    // Quick check for the worst case.\n    if (text1 == text2) {\n        return text_length;\n    }\n    // Start by looking for a single character match\n    // and increase length until no match is found.\n    // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n    var best = 0;\n    var length = 1;\n    while(true){\n        var pattern = text1.substring(text_length - length);\n        var found = text2.indexOf(pattern);\n        if (found == -1) {\n            return best;\n        }\n        length += found;\n        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {\n            best = length;\n            length++;\n        }\n    }\n};\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */ diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n    if (this.Diff_Timeout <= 0) {\n        // Don't risk returning a non-optimal diff if we have unlimited time.\n        return null;\n    }\n    var longtext = text1.length > text2.length ? text1 : text2;\n    var shorttext = text1.length > text2.length ? text2 : text1;\n    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n        return null; // Pointless.\n    }\n    var dmp = this; // 'this' becomes 'window' in a closure.\n    /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */ function diff_halfMatchI_(longtext, shorttext, i) {\n        // Start with a 1/4 length substring at position i as a seed.\n        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n        var j = -1;\n        var best_common = \"\";\n        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n        while((j = shorttext.indexOf(seed, j + 1)) != -1){\n            var prefixLength = dmp.diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n            var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n            if (best_common.length < suffixLength + prefixLength) {\n                best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n                best_longtext_a = longtext.substring(0, i - suffixLength);\n                best_longtext_b = longtext.substring(i + prefixLength);\n                best_shorttext_a = shorttext.substring(0, j - suffixLength);\n                best_shorttext_b = shorttext.substring(j + prefixLength);\n            }\n        }\n        if (best_common.length * 2 >= longtext.length) {\n            return [\n                best_longtext_a,\n                best_longtext_b,\n                best_shorttext_a,\n                best_shorttext_b,\n                best_common\n            ];\n        } else {\n            return null;\n        }\n    }\n    // First check if the second quarter is the seed for a half-match.\n    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n    // Check again based on the third quarter.\n    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n    var hm;\n    if (!hm1 && !hm2) {\n        return null;\n    } else if (!hm2) {\n        hm = hm1;\n    } else if (!hm1) {\n        hm = hm2;\n    } else {\n        // Both matched.  Select the longest.\n        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n    }\n    // A half-match was found, sort out the return data.\n    var text1_a, text1_b, text2_a, text2_b;\n    if (text1.length > text2.length) {\n        text1_a = hm[0];\n        text1_b = hm[1];\n        text2_a = hm[2];\n        text2_b = hm[3];\n    } else {\n        text2_a = hm[0];\n        text2_b = hm[1];\n        text1_a = hm[2];\n        text1_b = hm[3];\n    }\n    var mid_common = hm[4];\n    return [\n        text1_a,\n        text1_b,\n        text2_a,\n        text2_b,\n        mid_common\n    ];\n};\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */ diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n    var changes = false;\n    var equalities = []; // Stack of indices where equalities are found.\n    var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n    /** @type {?string} */ var lastEquality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    var pointer = 0; // Index of current position.\n    // Number of characters that changed prior to the equality.\n    var length_insertions1 = 0;\n    var length_deletions1 = 0;\n    // Number of characters that changed after the equality.\n    var length_insertions2 = 0;\n    var length_deletions2 = 0;\n    while(pointer < diffs.length){\n        if (diffs[pointer][0] == DIFF_EQUAL) {\n            equalities[equalitiesLength++] = pointer;\n            length_insertions1 = length_insertions2;\n            length_deletions1 = length_deletions2;\n            length_insertions2 = 0;\n            length_deletions2 = 0;\n            lastEquality = diffs[pointer][1];\n        } else {\n            if (diffs[pointer][0] == DIFF_INSERT) {\n                length_insertions2 += diffs[pointer][1].length;\n            } else {\n                length_deletions2 += diffs[pointer][1].length;\n            }\n            // Eliminate an equality that is smaller or equal to the edits on both\n            // sides of it.\n            if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n                // Duplicate record.\n                diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n                // Change second copy to insert.\n                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                // Throw away the equality we just deleted.\n                equalitiesLength--;\n                // Throw away the previous equality (it needs to be reevaluated).\n                equalitiesLength--;\n                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                length_insertions1 = 0; // Reset the counters.\n                length_deletions1 = 0;\n                length_insertions2 = 0;\n                length_deletions2 = 0;\n                lastEquality = null;\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n    // Normalize the diff.\n    if (changes) {\n        this.diff_cleanupMerge(diffs);\n    }\n    this.diff_cleanupSemanticLossless(diffs);\n    // Find any overlaps between deletions and insertions.\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n    //   -> <del>abc</del>xxx<ins>def</ins>\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\n    //   -> <ins>def</ins>xxx<del>abc</del>\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\n    pointer = 1;\n    while(pointer < diffs.length){\n        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {\n            var deletion = diffs[pointer - 1][1];\n            var insertion = diffs[pointer][1];\n            var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n            var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n            if (overlap_length1 >= overlap_length2) {\n                if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n                    // Overlap found.  Insert an equality and trim the surrounding edits.\n                    diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n                    diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n                    diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n                    pointer++;\n                }\n            } else {\n                if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n                    // Reverse overlap found.\n                    // Insert an equality and swap and trim the surrounding edits.\n                    diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n                    diffs[pointer - 1][0] = DIFF_INSERT;\n                    diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n                    diffs[pointer + 1][0] = DIFF_DELETE;\n                    diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n                    pointer++;\n                }\n            }\n            pointer++;\n        }\n        pointer++;\n    }\n};\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */ diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n    /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */ function diff_cleanupSemanticScore_(one, two) {\n        if (!one || !two) {\n            // Edges are the best.\n            return 6;\n        }\n        // Each port of this function behaves slightly differently due to\n        // subtle differences in each language's definition of things like\n        // 'whitespace'.  Since this function's purpose is largely cosmetic,\n        // the choice has been made to use each language's native features\n        // rather than force total conformity.\n        var char1 = one.charAt(one.length - 1);\n        var char2 = two.charAt(0);\n        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);\n        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);\n        var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);\n        var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);\n        var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);\n        var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);\n        if (blankLine1 || blankLine2) {\n            // Five points for blank lines.\n            return 5;\n        } else if (lineBreak1 || lineBreak2) {\n            // Four points for line breaks.\n            return 4;\n        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n            // Three points for end of sentences.\n            return 3;\n        } else if (whitespace1 || whitespace2) {\n            // Two points for whitespace.\n            return 2;\n        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n            // One point for non-alphanumeric.\n            return 1;\n        }\n        return 0;\n    }\n    var pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while(pointer < diffs.length - 1){\n        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n            // This is a single edit surrounded by equalities.\n            var equality1 = diffs[pointer - 1][1];\n            var edit = diffs[pointer][1];\n            var equality2 = diffs[pointer + 1][1];\n            // First, shift the edit as far left as possible.\n            var commonOffset = this.diff_commonSuffix(equality1, edit);\n            if (commonOffset) {\n                var commonString = edit.substring(edit.length - commonOffset);\n                equality1 = equality1.substring(0, equality1.length - commonOffset);\n                edit = commonString + edit.substring(0, edit.length - commonOffset);\n                equality2 = commonString + equality2;\n            }\n            // Second, step character by character right, looking for the best fit.\n            var bestEquality1 = equality1;\n            var bestEdit = edit;\n            var bestEquality2 = equality2;\n            var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n            while(edit.charAt(0) === equality2.charAt(0)){\n                equality1 += edit.charAt(0);\n                edit = edit.substring(1) + equality2.charAt(0);\n                equality2 = equality2.substring(1);\n                var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n                // The >= encourages trailing rather than leading whitespace on edits.\n                if (score >= bestScore) {\n                    bestScore = score;\n                    bestEquality1 = equality1;\n                    bestEdit = edit;\n                    bestEquality2 = equality2;\n                }\n            }\n            if (diffs[pointer - 1][1] != bestEquality1) {\n                // We have an improvement, save it back to the diff.\n                if (bestEquality1) {\n                    diffs[pointer - 1][1] = bestEquality1;\n                } else {\n                    diffs.splice(pointer - 1, 1);\n                    pointer--;\n                }\n                diffs[pointer][1] = bestEdit;\n                if (bestEquality2) {\n                    diffs[pointer + 1][1] = bestEquality2;\n                } else {\n                    diffs.splice(pointer + 1, 1);\n                    pointer--;\n                }\n            }\n        }\n        pointer++;\n    }\n};\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */ diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n    var changes = false;\n    var equalities = []; // Stack of indices where equalities are found.\n    var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n    /** @type {?string} */ var lastEquality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    var pointer = 0; // Index of current position.\n    // Is there an insertion operation before the last equality.\n    var pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    var pre_del = false;\n    // Is there an insertion operation after the last equality.\n    var post_ins = false;\n    // Is there a deletion operation after the last equality.\n    var post_del = false;\n    while(pointer < diffs.length){\n        if (diffs[pointer][0] == DIFF_EQUAL) {\n            if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {\n                // Candidate found.\n                equalities[equalitiesLength++] = pointer;\n                pre_ins = post_ins;\n                pre_del = post_del;\n                lastEquality = diffs[pointer][1];\n            } else {\n                // Not a candidate, and can never become one.\n                equalitiesLength = 0;\n                lastEquality = null;\n            }\n            post_ins = post_del = false;\n        } else {\n            if (diffs[pointer][0] == DIFF_DELETE) {\n                post_del = true;\n            } else {\n                post_ins = true;\n            }\n            /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */ if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {\n                // Duplicate record.\n                diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n                // Change second copy to insert.\n                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                equalitiesLength--; // Throw away the equality we just deleted;\n                lastEquality = null;\n                if (pre_ins && pre_del) {\n                    // No changes made which could affect previous entry, keep going.\n                    post_ins = post_del = true;\n                    equalitiesLength = 0;\n                } else {\n                    equalitiesLength--; // Throw away the previous equality.\n                    pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                    post_ins = post_del = false;\n                }\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n    if (changes) {\n        this.diff_cleanupMerge(diffs);\n    }\n};\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */ diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n    // Add a dummy entry at the end.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, \"\"));\n    var pointer = 0;\n    var count_delete = 0;\n    var count_insert = 0;\n    var text_delete = \"\";\n    var text_insert = \"\";\n    var commonlength;\n    while(pointer < diffs.length){\n        switch(diffs[pointer][0]){\n            case DIFF_INSERT:\n                count_insert++;\n                text_insert += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_DELETE:\n                count_delete++;\n                text_delete += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_EQUAL:\n                // Upon reaching an equality, check for prior redundancies.\n                if (count_delete + count_insert > 1) {\n                    if (count_delete !== 0 && count_insert !== 0) {\n                        // Factor out any common prefixies.\n                        commonlength = this.diff_commonPrefix(text_insert, text_delete);\n                        if (commonlength !== 0) {\n                            if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n                            } else {\n                                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                                pointer++;\n                            }\n                            text_insert = text_insert.substring(commonlength);\n                            text_delete = text_delete.substring(commonlength);\n                        }\n                        // Factor out any common suffixies.\n                        commonlength = this.diff_commonSuffix(text_insert, text_delete);\n                        if (commonlength !== 0) {\n                            diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n                            text_insert = text_insert.substring(0, text_insert.length - commonlength);\n                            text_delete = text_delete.substring(0, text_delete.length - commonlength);\n                        }\n                    }\n                    // Delete the offending records and add the merged ones.\n                    pointer -= count_delete + count_insert;\n                    diffs.splice(pointer, count_delete + count_insert);\n                    if (text_delete.length) {\n                        diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n                        pointer++;\n                    }\n                    if (text_insert.length) {\n                        diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n                        pointer++;\n                    }\n                    pointer++;\n                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n                    // Merge this equality with the previous one.\n                    diffs[pointer - 1][1] += diffs[pointer][1];\n                    diffs.splice(pointer, 1);\n                } else {\n                    pointer++;\n                }\n                count_insert = 0;\n                count_delete = 0;\n                text_delete = \"\";\n                text_insert = \"\";\n                break;\n        }\n    }\n    if (diffs[diffs.length - 1][1] === \"\") {\n        diffs.pop(); // Remove the dummy entry at the end.\n    }\n    // Second pass: look for single edits surrounded on both sides by equalities\n    // which can be shifted sideways to eliminate an equality.\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n    var changes = false;\n    pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while(pointer < diffs.length - 1){\n        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n            // This is a single edit surrounded by equalities.\n            if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n                // Shift the edit over the previous equality.\n                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                diffs.splice(pointer - 1, 1);\n                changes = true;\n            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n                // Shift the edit over the next equality.\n                diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n                diffs.splice(pointer + 1, 1);\n                changes = true;\n            }\n        }\n        pointer++;\n    }\n    // If shifts were made, the diff needs reordering and another shift sweep.\n    if (changes) {\n        this.diff_cleanupMerge(diffs);\n    }\n};\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */ diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n    var chars1 = 0;\n    var chars2 = 0;\n    var last_chars1 = 0;\n    var last_chars2 = 0;\n    var x;\n    for(x = 0; x < diffs.length; x++){\n        if (diffs[x][0] !== DIFF_INSERT) {\n            chars1 += diffs[x][1].length;\n        }\n        if (diffs[x][0] !== DIFF_DELETE) {\n            chars2 += diffs[x][1].length;\n        }\n        if (chars1 > loc) {\n            break;\n        }\n        last_chars1 = chars1;\n        last_chars2 = chars2;\n    }\n    // Was the location was deleted?\n    if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n        return last_chars2;\n    }\n    // Add the remaining character length.\n    return last_chars2 + (loc - last_chars1);\n};\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */ diff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n    var html = [];\n    var pattern_amp = /&/g;\n    var pattern_lt = /</g;\n    var pattern_gt = />/g;\n    var pattern_para = /\\n/g;\n    for(var x = 0; x < diffs.length; x++){\n        var op = diffs[x][0]; // Operation (insert, delete, equal)\n        var data = diffs[x][1]; // Text of change.\n        var text = data.replace(pattern_amp, \"&amp;\").replace(pattern_lt, \"&lt;\").replace(pattern_gt, \"&gt;\").replace(pattern_para, \"&para;<br>\");\n        switch(op){\n            case DIFF_INSERT:\n                html[x] = '<ins style=\"background:#e6ffe6;\">' + text + \"</ins>\";\n                break;\n            case DIFF_DELETE:\n                html[x] = '<del style=\"background:#ffe6e6;\">' + text + \"</del>\";\n                break;\n            case DIFF_EQUAL:\n                html[x] = \"<span>\" + text + \"</span>\";\n                break;\n        }\n    }\n    return html.join(\"\");\n};\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */ diff_match_patch.prototype.diff_text1 = function(diffs) {\n    var text = [];\n    for(var x = 0; x < diffs.length; x++){\n        if (diffs[x][0] !== DIFF_INSERT) {\n            text[x] = diffs[x][1];\n        }\n    }\n    return text.join(\"\");\n};\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */ diff_match_patch.prototype.diff_text2 = function(diffs) {\n    var text = [];\n    for(var x = 0; x < diffs.length; x++){\n        if (diffs[x][0] !== DIFF_DELETE) {\n            text[x] = diffs[x][1];\n        }\n    }\n    return text.join(\"\");\n};\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */ diff_match_patch.prototype.diff_levenshtein = function(diffs) {\n    var levenshtein = 0;\n    var insertions = 0;\n    var deletions = 0;\n    for(var x = 0; x < diffs.length; x++){\n        var op = diffs[x][0];\n        var data = diffs[x][1];\n        switch(op){\n            case DIFF_INSERT:\n                insertions += data.length;\n                break;\n            case DIFF_DELETE:\n                deletions += data.length;\n                break;\n            case DIFF_EQUAL:\n                // A deletion and an insertion is one substitution.\n                levenshtein += Math.max(insertions, deletions);\n                insertions = 0;\n                deletions = 0;\n                break;\n        }\n    }\n    levenshtein += Math.max(insertions, deletions);\n    return levenshtein;\n};\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */ diff_match_patch.prototype.diff_toDelta = function(diffs) {\n    var text = [];\n    for(var x = 0; x < diffs.length; x++){\n        switch(diffs[x][0]){\n            case DIFF_INSERT:\n                text[x] = \"+\" + encodeURI(diffs[x][1]);\n                break;\n            case DIFF_DELETE:\n                text[x] = \"-\" + diffs[x][1].length;\n                break;\n            case DIFF_EQUAL:\n                text[x] = \"=\" + diffs[x][1].length;\n                break;\n        }\n    }\n    return text.join(\"\t\").replace(/%20/g, \" \");\n};\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */ diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n    var diffs = [];\n    var diffsLength = 0; // Keeping our own length var is faster in JS.\n    var pointer = 0; // Cursor in text1\n    var tokens = delta.split(/\\t/g);\n    for(var x = 0; x < tokens.length; x++){\n        // Each token begins with a one character parameter which specifies the\n        // operation of this token (delete, insert, equality).\n        var param = tokens[x].substring(1);\n        switch(tokens[x].charAt(0)){\n            case \"+\":\n                try {\n                    diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n                } catch (ex) {\n                    // Malformed URI sequence.\n                    throw new Error(\"Illegal escape in diff_fromDelta: \" + param);\n                }\n                break;\n            case \"-\":\n            // Fall through.\n            case \"=\":\n                var n = parseInt(param, 10);\n                if (isNaN(n) || n < 0) {\n                    throw new Error(\"Invalid number in diff_fromDelta: \" + param);\n                }\n                var text = text1.substring(pointer, pointer += n);\n                if (tokens[x].charAt(0) == \"=\") {\n                    diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n                } else {\n                    diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n                }\n                break;\n            default:\n                // Blank tokens are ok (from a trailing \\t).\n                // Anything else is an error.\n                if (tokens[x]) {\n                    throw new Error(\"Invalid diff operation in diff_fromDelta: \" + tokens[x]);\n                }\n        }\n    }\n    if (pointer != text1.length) {\n        throw new Error(\"Delta length (\" + pointer + \") does not equal source text length (\" + text1.length + \").\");\n    }\n    return diffs;\n};\n//  MATCH FUNCTIONS\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */ diff_match_patch.prototype.match_main = function(text, pattern, loc) {\n    // Check for null inputs.\n    if (text == null || pattern == null || loc == null) {\n        throw new Error(\"Null input. (match_main)\");\n    }\n    loc = Math.max(0, Math.min(loc, text.length));\n    if (text == pattern) {\n        // Shortcut (potentially not guaranteed by the algorithm)\n        return 0;\n    } else if (!text.length) {\n        // Nothing to match.\n        return -1;\n    } else if (text.substring(loc, loc + pattern.length) == pattern) {\n        // Perfect match at the perfect spot!  (Includes case of null pattern)\n        return loc;\n    } else {\n        // Do a fuzzy compare.\n        return this.match_bitap_(text, pattern, loc);\n    }\n};\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */ diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n    if (pattern.length > this.Match_MaxBits) {\n        throw new Error(\"Pattern too long for this browser.\");\n    }\n    // Initialise the alphabet.\n    var s = this.match_alphabet_(pattern);\n    var dmp = this; // 'this' becomes 'window' in a closure.\n    /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */ function match_bitapScore_(e, x) {\n        var accuracy = e / pattern.length;\n        var proximity = Math.abs(loc - x);\n        if (!dmp.Match_Distance) {\n            // Dodge divide by zero error.\n            return proximity ? 1.0 : accuracy;\n        }\n        return accuracy + proximity / dmp.Match_Distance;\n    }\n    // Highest score beyond which we give up.\n    var score_threshold = this.Match_Threshold;\n    // Is there a nearby exact match? (speedup)\n    var best_loc = text.indexOf(pattern, loc);\n    if (best_loc != -1) {\n        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n        // What about in the other direction? (speedup)\n        best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n        if (best_loc != -1) {\n            score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n        }\n    }\n    // Initialise the bit arrays.\n    var matchmask = 1 << pattern.length - 1;\n    best_loc = -1;\n    var bin_min, bin_mid;\n    var bin_max = pattern.length + text.length;\n    var last_rd;\n    for(var d = 0; d < pattern.length; d++){\n        // Scan for the best match; each iteration allows for one more error.\n        // Run a binary search to determine how far from 'loc' we can stray at this\n        // error level.\n        bin_min = 0;\n        bin_mid = bin_max;\n        while(bin_min < bin_mid){\n            if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n                bin_min = bin_mid;\n            } else {\n                bin_max = bin_mid;\n            }\n            bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n        }\n        // Use the result from this iteration as the maximum for the next.\n        bin_max = bin_mid;\n        var start = Math.max(1, loc - bin_mid + 1);\n        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n        var rd = Array(finish + 2);\n        rd[finish + 1] = (1 << d) - 1;\n        for(var j = finish; j >= start; j--){\n            // The alphabet (s) is a sparse hash, so the following line generates\n            // warnings.\n            var charMatch = s[text.charAt(j - 1)];\n            if (d === 0) {\n                rd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n            } else {\n                rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];\n            }\n            if (rd[j] & matchmask) {\n                var score = match_bitapScore_(d, j - 1);\n                // This match will almost certainly be better than any existing match.\n                // But check anyway.\n                if (score <= score_threshold) {\n                    // Told you so.\n                    score_threshold = score;\n                    best_loc = j - 1;\n                    if (best_loc > loc) {\n                        // When passing loc, don't exceed our current distance from loc.\n                        start = Math.max(1, 2 * loc - best_loc);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        // No hope for a (better) match at greater error levels.\n        if (match_bitapScore_(d + 1, loc) > score_threshold) {\n            break;\n        }\n        last_rd = rd;\n    }\n    return best_loc;\n};\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */ diff_match_patch.prototype.match_alphabet_ = function(pattern) {\n    var s = {};\n    for(var i = 0; i < pattern.length; i++){\n        s[pattern.charAt(i)] = 0;\n    }\n    for(var i = 0; i < pattern.length; i++){\n        s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n    }\n    return s;\n};\n//  PATCH FUNCTIONS\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */ diff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n    if (text.length == 0) {\n        return;\n    }\n    if (patch.start2 === null) {\n        throw Error(\"patch not initialized\");\n    }\n    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n    var padding = 0;\n    // Look for the first and last matches of pattern in text.  If two different\n    // matches are found, increase the pattern length.\n    while(text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin){\n        padding += this.Patch_Margin;\n        pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n    }\n    // Add one chunk for good luck.\n    padding += this.Patch_Margin;\n    // Add the prefix.\n    var prefix = text.substring(patch.start2 - padding, patch.start2);\n    if (prefix) {\n        patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n    }\n    // Add the suffix.\n    var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);\n    if (suffix) {\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n    }\n    // Roll back the start points.\n    patch.start1 -= prefix.length;\n    patch.start2 -= prefix.length;\n    // Extend the lengths.\n    patch.length1 += prefix.length + suffix.length;\n    patch.length2 += prefix.length + suffix.length;\n};\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */ diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n    var text1, diffs;\n    if (typeof a == \"string\" && typeof opt_b == \"string\" && typeof opt_c == \"undefined\") {\n        // Method 1: text1, text2\n        // Compute diffs from text1 and text2.\n        text1 = /** @type {string} */ a;\n        diffs = this.diff_main(text1, /** @type {string} */ opt_b, true);\n        if (diffs.length > 2) {\n            this.diff_cleanupSemantic(diffs);\n            this.diff_cleanupEfficiency(diffs);\n        }\n    } else if (a && typeof a == \"object\" && typeof opt_b == \"undefined\" && typeof opt_c == \"undefined\") {\n        // Method 2: diffs\n        // Compute text1 from diffs.\n        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ a;\n        text1 = this.diff_text1(diffs);\n    } else if (typeof a == \"string\" && opt_b && typeof opt_b == \"object\" && typeof opt_c == \"undefined\") {\n        // Method 3: text1, diffs\n        text1 = /** @type {string} */ a;\n        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ opt_b;\n    } else if (typeof a == \"string\" && typeof opt_b == \"string\" && opt_c && typeof opt_c == \"object\") {\n        // Method 4: text1, text2, diffs\n        // text2 is not used.\n        text1 = /** @type {string} */ a;\n        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ opt_c;\n    } else {\n        throw new Error(\"Unknown call format to patch_make.\");\n    }\n    if (diffs.length === 0) {\n        return []; // Get rid of the null case.\n    }\n    var patches = [];\n    var patch = new diff_match_patch.patch_obj();\n    var patchDiffLength = 0; // Keeping our own length var is faster in JS.\n    var char_count1 = 0; // Number of characters into the text1 string.\n    var char_count2 = 0; // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text).  We recreate the patches one by one to determine\n    // context info.\n    var prepatch_text = text1;\n    var postpatch_text = text1;\n    for(var x = 0; x < diffs.length; x++){\n        var diff_type = diffs[x][0];\n        var diff_text = diffs[x][1];\n        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n            // A new patch starts here.\n            patch.start1 = char_count1;\n            patch.start2 = char_count2;\n        }\n        switch(diff_type){\n            case DIFF_INSERT:\n                patch.diffs[patchDiffLength++] = diffs[x];\n                patch.length2 += diff_text.length;\n                postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);\n                break;\n            case DIFF_DELETE:\n                patch.length1 += diff_text.length;\n                patch.diffs[patchDiffLength++] = diffs[x];\n                postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);\n                break;\n            case DIFF_EQUAL:\n                if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {\n                    // Small equality inside a patch.\n                    patch.diffs[patchDiffLength++] = diffs[x];\n                    patch.length1 += diff_text.length;\n                    patch.length2 += diff_text.length;\n                } else if (diff_text.length >= 2 * this.Patch_Margin) {\n                    // Time for a new patch.\n                    if (patchDiffLength) {\n                        this.patch_addContext_(patch, prepatch_text);\n                        patches.push(patch);\n                        patch = new diff_match_patch.patch_obj();\n                        patchDiffLength = 0;\n                        // Unlike Unidiff, our patch lists have a rolling context.\n                        // https://github.com/google/diff-match-patch/wiki/Unidiff\n                        // Update prepatch text & pos to reflect the application of the\n                        // just completed patch.\n                        prepatch_text = postpatch_text;\n                        char_count1 = char_count2;\n                    }\n                }\n                break;\n        }\n        // Update the current character count.\n        if (diff_type !== DIFF_INSERT) {\n            char_count1 += diff_text.length;\n        }\n        if (diff_type !== DIFF_DELETE) {\n            char_count2 += diff_text.length;\n        }\n    }\n    // Pick up the leftover patch if not empty.\n    if (patchDiffLength) {\n        this.patch_addContext_(patch, prepatch_text);\n        patches.push(patch);\n    }\n    return patches;\n};\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */ diff_match_patch.prototype.patch_deepCopy = function(patches) {\n    // Making deep copies is hard in JavaScript.\n    var patchesCopy = [];\n    for(var x = 0; x < patches.length; x++){\n        var patch = patches[x];\n        var patchCopy = new diff_match_patch.patch_obj();\n        patchCopy.diffs = [];\n        for(var y = 0; y < patch.diffs.length; y++){\n            patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n        }\n        patchCopy.start1 = patch.start1;\n        patchCopy.start2 = patch.start2;\n        patchCopy.length1 = patch.length1;\n        patchCopy.length2 = patch.length2;\n        patchesCopy[x] = patchCopy;\n    }\n    return patchesCopy;\n};\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */ diff_match_patch.prototype.patch_apply = function(patches, text) {\n    if (patches.length == 0) {\n        return [\n            text,\n            []\n        ];\n    }\n    // Deep copy the patches so that no changes are made to originals.\n    patches = this.patch_deepCopy(patches);\n    var nullPadding = this.patch_addPadding(patches);\n    text = nullPadding + text + nullPadding;\n    this.patch_splitMax(patches);\n    // delta keeps track of the offset between the expected and actual location\n    // of the previous patch.  If there are patches expected at positions 10 and\n    // 20, but the first patch was found at 12, delta is 2 and the second patch\n    // has an effective expected position of 22.\n    var delta = 0;\n    var results = [];\n    for(var x = 0; x < patches.length; x++){\n        var expected_loc = patches[x].start2 + delta;\n        var text1 = this.diff_text1(patches[x].diffs);\n        var start_loc;\n        var end_loc = -1;\n        if (text1.length > this.Match_MaxBits) {\n            // patch_splitMax will only provide an oversized pattern in the case of\n            // a monster delete.\n            start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);\n            if (start_loc != -1) {\n                end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);\n                if (end_loc == -1 || start_loc >= end_loc) {\n                    // Can't find valid trailing context.  Drop this patch.\n                    start_loc = -1;\n                }\n            }\n        } else {\n            start_loc = this.match_main(text, text1, expected_loc);\n        }\n        if (start_loc == -1) {\n            // No match found.  :(\n            results[x] = false;\n            // Subtract the delta for this failed patch from subsequent patches.\n            delta -= patches[x].length2 - patches[x].length1;\n        } else {\n            // Found a match.  :)\n            results[x] = true;\n            delta = start_loc - expected_loc;\n            var text2;\n            if (end_loc == -1) {\n                text2 = text.substring(start_loc, start_loc + text1.length);\n            } else {\n                text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n            }\n            if (text1 == text2) {\n                // Perfect match, just shove the replacement text in.\n                text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);\n            } else {\n                // Imperfect match.  Run a diff to get a framework of equivalent\n                // indices.\n                var diffs = this.diff_main(text1, text2, false);\n                if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {\n                    // The end points match, but the content is unacceptably bad.\n                    results[x] = false;\n                } else {\n                    this.diff_cleanupSemanticLossless(diffs);\n                    var index1 = 0;\n                    var index2;\n                    for(var y = 0; y < patches[x].diffs.length; y++){\n                        var mod = patches[x].diffs[y];\n                        if (mod[0] !== DIFF_EQUAL) {\n                            index2 = this.diff_xIndex(diffs, index1);\n                        }\n                        if (mod[0] === DIFF_INSERT) {\n                            text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);\n                        } else if (mod[0] === DIFF_DELETE) {\n                            text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));\n                        }\n                        if (mod[0] !== DIFF_DELETE) {\n                            index1 += mod[1].length;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Strip the padding off.\n    text = text.substring(nullPadding.length, text.length - nullPadding.length);\n    return [\n        text,\n        results\n    ];\n};\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */ diff_match_patch.prototype.patch_addPadding = function(patches) {\n    var paddingLength = this.Patch_Margin;\n    var nullPadding = \"\";\n    for(var x = 1; x <= paddingLength; x++){\n        nullPadding += String.fromCharCode(x);\n    }\n    // Bump all the patches forward.\n    for(var x = 0; x < patches.length; x++){\n        patches[x].start1 += paddingLength;\n        patches[x].start2 += paddingLength;\n    }\n    // Add some padding on start of first diff.\n    var patch = patches[0];\n    var diffs = patch.diffs;\n    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n        // Add nullPadding equality.\n        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n        patch.start1 -= paddingLength; // Should be 0.\n        patch.start2 -= paddingLength; // Should be 0.\n        patch.length1 += paddingLength;\n        patch.length2 += paddingLength;\n    } else if (paddingLength > diffs[0][1].length) {\n        // Grow first equality.\n        var extraLength = paddingLength - diffs[0][1].length;\n        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n        patch.start1 -= extraLength;\n        patch.start2 -= extraLength;\n        patch.length1 += extraLength;\n        patch.length2 += extraLength;\n    }\n    // Add some padding on end of last diff.\n    patch = patches[patches.length - 1];\n    diffs = patch.diffs;\n    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n        // Add nullPadding equality.\n        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n        patch.length1 += paddingLength;\n        patch.length2 += paddingLength;\n    } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n        // Grow last equality.\n        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n        patch.length1 += extraLength;\n        patch.length2 += extraLength;\n    }\n    return nullPadding;\n};\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */ diff_match_patch.prototype.patch_splitMax = function(patches) {\n    var patch_size = this.Match_MaxBits;\n    for(var x = 0; x < patches.length; x++){\n        if (patches[x].length1 <= patch_size) {\n            continue;\n        }\n        var bigpatch = patches[x];\n        // Remove the big old patch.\n        patches.splice(x--, 1);\n        var start1 = bigpatch.start1;\n        var start2 = bigpatch.start2;\n        var precontext = \"\";\n        while(bigpatch.diffs.length !== 0){\n            // Create one of several smaller patches.\n            var patch = new diff_match_patch.patch_obj();\n            var empty = true;\n            patch.start1 = start1 - precontext.length;\n            patch.start2 = start2 - precontext.length;\n            if (precontext !== \"\") {\n                patch.length1 = patch.length2 = precontext.length;\n                patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n            }\n            while(bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin){\n                var diff_type = bigpatch.diffs[0][0];\n                var diff_text = bigpatch.diffs[0][1];\n                if (diff_type === DIFF_INSERT) {\n                    // Insertions are harmless.\n                    patch.length2 += diff_text.length;\n                    start2 += diff_text.length;\n                    patch.diffs.push(bigpatch.diffs.shift());\n                    empty = false;\n                } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {\n                    // This is a large deletion.  Let it pass in one chunk.\n                    patch.length1 += diff_text.length;\n                    start1 += diff_text.length;\n                    empty = false;\n                    patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n                    bigpatch.diffs.shift();\n                } else {\n                    // Deletion or equality.  Only take as much as we can stomach.\n                    diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);\n                    patch.length1 += diff_text.length;\n                    start1 += diff_text.length;\n                    if (diff_type === DIFF_EQUAL) {\n                        patch.length2 += diff_text.length;\n                        start2 += diff_text.length;\n                    } else {\n                        empty = false;\n                    }\n                    patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n                    if (diff_text == bigpatch.diffs[0][1]) {\n                        bigpatch.diffs.shift();\n                    } else {\n                        bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);\n                    }\n                }\n            }\n            // Compute the head context for the next patch.\n            precontext = this.diff_text2(patch.diffs);\n            precontext = precontext.substring(precontext.length - this.Patch_Margin);\n            // Append the end context for this patch.\n            var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);\n            if (postcontext !== \"\") {\n                patch.length1 += postcontext.length;\n                patch.length2 += postcontext.length;\n                if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n                    patch.diffs[patch.diffs.length - 1][1] += postcontext;\n                } else {\n                    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n                }\n            }\n            if (!empty) {\n                patches.splice(++x, 0, patch);\n            }\n        }\n    }\n};\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */ diff_match_patch.prototype.patch_toText = function(patches) {\n    var text = [];\n    for(var x = 0; x < patches.length; x++){\n        text[x] = patches[x];\n    }\n    return text.join(\"\");\n};\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */ diff_match_patch.prototype.patch_fromText = function(textline) {\n    var patches = [];\n    if (!textline) {\n        return patches;\n    }\n    var text = textline.split(\"\\n\");\n    var textPointer = 0;\n    var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n    while(textPointer < text.length){\n        var m = text[textPointer].match(patchHeader);\n        if (!m) {\n            throw new Error(\"Invalid patch string: \" + text[textPointer]);\n        }\n        var patch = new diff_match_patch.patch_obj();\n        patches.push(patch);\n        patch.start1 = parseInt(m[1], 10);\n        if (m[2] === \"\") {\n            patch.start1--;\n            patch.length1 = 1;\n        } else if (m[2] == \"0\") {\n            patch.length1 = 0;\n        } else {\n            patch.start1--;\n            patch.length1 = parseInt(m[2], 10);\n        }\n        patch.start2 = parseInt(m[3], 10);\n        if (m[4] === \"\") {\n            patch.start2--;\n            patch.length2 = 1;\n        } else if (m[4] == \"0\") {\n            patch.length2 = 0;\n        } else {\n            patch.start2--;\n            patch.length2 = parseInt(m[4], 10);\n        }\n        textPointer++;\n        while(textPointer < text.length){\n            var sign = text[textPointer].charAt(0);\n            try {\n                var line = decodeURI(text[textPointer].substring(1));\n            } catch (ex) {\n                // Malformed URI sequence.\n                throw new Error(\"Illegal escape in patch_fromText: \" + line);\n            }\n            if (sign == \"-\") {\n                // Deletion.\n                patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n            } else if (sign == \"+\") {\n                // Insertion.\n                patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n            } else if (sign == \" \") {\n                // Minor equality.\n                patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n            } else if (sign == \"@\") {\n                break;\n            } else if (sign === \"\") {\n            // Blank line?  Whatever.\n            } else {\n                // WTF?\n                throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n            }\n            textPointer++;\n        }\n    }\n    return patches;\n};\n/**\n * Class representing one patch operation.\n * @constructor\n */ diff_match_patch.patch_obj = function() {\n    /** @type {!Array.<!diff_match_patch.Diff>} */ this.diffs = [];\n    /** @type {?number} */ this.start1 = null;\n    /** @type {?number} */ this.start2 = null;\n    /** @type {number} */ this.length1 = 0;\n    /** @type {number} */ this.length2 = 0;\n};\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */ diff_match_patch.patch_obj.prototype.toString = function() {\n    var coords1, coords2;\n    if (this.length1 === 0) {\n        coords1 = this.start1 + \",0\";\n    } else if (this.length1 == 1) {\n        coords1 = this.start1 + 1;\n    } else {\n        coords1 = this.start1 + 1 + \",\" + this.length1;\n    }\n    if (this.length2 === 0) {\n        coords2 = this.start2 + \",0\";\n    } else if (this.length2 == 1) {\n        coords2 = this.start2 + 1;\n    } else {\n        coords2 = this.start2 + 1 + \",\" + this.length2;\n    }\n    var text = [\n        \"@@ -\" + coords1 + \" +\" + coords2 + \" @@\\n\"\n    ];\n    var op;\n    // Escape the body of the patch with %xx notation.\n    for(var x = 0; x < this.diffs.length; x++){\n        switch(this.diffs[x][0]){\n            case DIFF_INSERT:\n                op = \"+\";\n                break;\n            case DIFF_DELETE:\n                op = \"-\";\n                break;\n            case DIFF_EQUAL:\n                op = \" \";\n                break;\n        }\n        text[x + 1] = op + encodeURI(this.diffs[x][1]) + \"\\n\";\n    }\n    return text.join(\"\").replace(/%20/g, \" \");\n};\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports.diff_match_patch = diff_match_patch;\nmodule.exports.DIFF_DELETE = DIFF_DELETE;\nmodule.exports.DIFF_INSERT = DIFF_INSERT;\nmodule.exports.DIFF_EQUAL = DIFF_EQUAL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVEOzs7O0NBSUMsR0FFRDs7O0NBR0M7QUFDRCxJQUFJQSxtQkFBbUI7SUFFckIsWUFBWTtJQUNaLDJEQUEyRDtJQUUzRCxxRUFBcUU7SUFDckUsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFDcEIsK0RBQStEO0lBQy9ELElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBQ3JCLDJFQUEyRTtJQUMzRSxJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QiwyRUFBMkU7SUFDM0Usd0VBQXdFO0lBQ3hFLDZDQUE2QztJQUM3QyxJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QiwwRUFBMEU7SUFDMUUsNkVBQTZFO0lBQzdFLHlFQUF5RTtJQUN6RSx3Q0FBd0M7SUFDeEMsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztJQUM3QixpQ0FBaUM7SUFDakMsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFFcEIsZ0NBQWdDO0lBQ2hDLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0FBQ3ZCO0FBR0Esa0JBQWtCO0FBR2xCOzs7O0NBSUMsR0FDRCxJQUFJQyxjQUFjLENBQUM7QUFDbkIsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxhQUFhO0FBRWpCOzs7Ozs7OztDQVFDLEdBQ0RWLGlCQUFpQlcsSUFBSSxHQUFHLFNBQVNDLEVBQUUsRUFBRUMsSUFBSTtJQUN2QyxPQUFPO1FBQUNEO1FBQUlDO0tBQUs7QUFDbkI7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRGIsaUJBQWlCYyxTQUFTLENBQUNDLFNBQVMsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsY0FBYyxFQUN4RUMsWUFBWTtJQUNkLDBEQUEwRDtJQUMxRCxJQUFJLE9BQU9BLGdCQUFnQixhQUFhO1FBQ3RDLElBQUksSUFBSSxDQUFDbEIsWUFBWSxJQUFJLEdBQUc7WUFDMUJrQixlQUFlQyxP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LHlEQUF5RDtBQUN6RDZGLE9BQU9DLE9BQU8sR0FBR3pTO0FBQ2pCd1MsK0JBQWtDLEdBQUd4UztBQUNyQ3dTLDBCQUE2QixHQUFHaFM7QUFDaENnUywwQkFBNkIsR0FBRy9SO0FBQ2hDK1IseUJBQTRCLEdBQUc5UiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gvaW5kZXguanM/NzNiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgZGlmZi1tYXRjaC1wYXRjaCBBdXRob3JzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9kaWZmLW1hdGNoLXBhdGNoXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGV4dHMgdG8gY3JlYXRlIGEgcGF0Y2guXG4gKiBBcHBsaWVzIHRoZSBwYXRjaCBvbnRvIGFub3RoZXIgdGV4dCwgYWxsb3dpbmcgZm9yIGVycm9ycy5cbiAqIEBhdXRob3IgZnJhc2VyQGdvb2dsZS5jb20gKE5laWwgRnJhc2VyKVxuICovXG5cbi8qKlxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIGRpZmZfbWF0Y2hfcGF0Y2ggPSBmdW5jdGlvbigpIHtcblxuICAvLyBEZWZhdWx0cy5cbiAgLy8gUmVkZWZpbmUgdGhlc2UgaW4geW91ciBwcm9ncmFtIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cblxuICAvLyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cbiAgdGhpcy5EaWZmX1RpbWVvdXQgPSAxLjA7XG4gIC8vIENvc3Qgb2YgYW4gZW1wdHkgZWRpdCBvcGVyYXRpb24gaW4gdGVybXMgb2YgZWRpdCBjaGFyYWN0ZXJzLlxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xuICAvLyBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cbiAgdGhpcy5NYXRjaF9UaHJlc2hvbGQgPSAwLjU7XG4gIC8vIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAvLyBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgLy8gMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gIHRoaXMuTWF0Y2hfRGlzdGFuY2UgPSAxMDAwO1xuICAvLyBXaGVuIGRlbGV0aW5nIGEgbGFyZ2UgYmxvY2sgb2YgdGV4dCAob3ZlciB+NjQgY2hhcmFjdGVycyksIGhvdyBjbG9zZSBkb1xuICAvLyB0aGUgY29udGVudHMgaGF2ZSB0byBiZSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgY29udGVudHMuICgwLjAgPSBwZXJmZWN0aW9uLFxuICAvLyAxLjAgPSB2ZXJ5IGxvb3NlKS4gIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXG4gIC8vIGVuZCBwb2ludHMgb2YgYSBkZWxldGUgbmVlZCB0byBtYXRjaC5cbiAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQgPSAwLjU7XG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxuICB0aGlzLlBhdGNoX01hcmdpbiA9IDQ7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgdGhpcy5NYXRjaF9NYXhCaXRzID0gMzI7XG59O1xuXG5cbi8vICBESUZGIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXG4gKi9cbnZhciBESUZGX0RFTEVURSA9IC0xO1xudmFyIERJRkZfSU5TRVJUID0gMTtcbnZhciBESUZGX0VRVUFMID0gMDtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIGRpZmYgdHVwbGUuXG4gKiB+QXR0ZW1wdHMgdG8gbG9vayBsaWtlIGEgdHdvLWVsZW1lbnQgYXJyYXkgKHdoaWNoIGlzIHdoYXQgdGhpcyB1c2VkIHRvIGJlKS5+XG4gKiBDb25zdHJ1Y3RvciByZXR1cm5zIGFuIGFjdHVhbCB0d28tZWxlbWVudCBhcnJheSwgdG8gYWxsb3cgZGVzdHJ1Y3RpbmcgQEphY2t1QlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9KYWNrdUIvZGlmZi1tYXRjaC1wYXRjaC9pc3N1ZXMvMTQgZm9yIGRldGFpbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcCBPcGVyYXRpb24sIG9uZSBvZjogRElGRl9ERUxFVEUsIERJRkZfSU5TRVJULCBESUZGX0VRVUFMLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dCB0byBiZSBkZWxldGVkLCBpbnNlcnRlZCwgb3IgcmV0YWluZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5EaWZmID0gZnVuY3Rpb24ob3AsIHRleHQpIHtcbiAgcmV0dXJuIFtvcCwgdGV4dF07XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcbiAqIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeCBvZmYgdGhlIHRleHRzIGJlZm9yZSBkaWZmaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NoZWNrbGluZXMgT3B0aW9uYWwgc3BlZWR1cCBmbGFnLiBJZiBwcmVzZW50IGFuZCBmYWxzZSxcbiAqICAgICB0aGVuIGRvbid0IHJ1biBhIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RlYWRsaW5lIE9wdGlvbmFsIHRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGVcbiAqICAgICBieS4gIFVzZWQgaW50ZXJuYWxseSBmb3IgcmVjdXJzaXZlIGNhbGxzLiAgVXNlcnMgc2hvdWxkIHNldCBEaWZmVGltZW91dFxuICogICAgIGluc3RlYWQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9tYWluID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBvcHRfY2hlY2tsaW5lcyxcbiAgICBvcHRfZGVhZGxpbmUpIHtcbiAgLy8gU2V0IGEgZGVhZGxpbmUgYnkgd2hpY2ggdGltZSB0aGUgZGlmZiBtdXN0IGJlIGNvbXBsZXRlLlxuICBpZiAodHlwZW9mIG9wdF9kZWFkbGluZSA9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0aGlzLkRpZmZfVGltZW91dCA8PSAwKSB7XG4gICAgICBvcHRfZGVhZGxpbmUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRfZGVhZGxpbmUgPSAobmV3IERhdGUpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcbiAgICB9XG4gIH1cbiAgdmFyIGRlYWRsaW5lID0gb3B0X2RlYWRsaW5lO1xuXG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgaWYgKHRleHQxID09IG51bGwgfHwgdGV4dDIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBpbnB1dC4gKGRpZmZfbWFpbiknKTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cCkuXG4gIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xuICAgIGlmICh0ZXh0MSkge1xuICAgICAgcmV0dXJuIFtuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsIHRleHQxKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XG4gIH1cbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcblxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKS5cbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcblxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBjb21tb25wcmVmaXgpKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeCkpO1xuICB9XG4gIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxuICogaGF2ZSBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXguXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrbGluZXMgU3BlZWR1cCBmbGFnLiAgSWYgZmFsc2UsIHRoZW4gZG9uJ3QgcnVuIGFcbiAqICAgICBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXG4gKiAgICAgSWYgdHJ1ZSwgdGhlbiBydW4gYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZV8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsXG4gICAgZGVhZGxpbmUpIHtcbiAgdmFyIGRpZmZzO1xuXG4gIGlmICghdGV4dDEpIHtcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0lOU0VSVCwgdGV4dDIpXTtcbiAgfVxuXG4gIGlmICghdGV4dDIpIHtcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0RFTEVURSwgdGV4dDEpXTtcbiAgfVxuXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT0gLTEpIHtcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXG4gICAgZGlmZnMgPSBbbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpKSxcbiAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsIHNob3J0dGV4dCksXG4gICAgICAgICAgICAgbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0lOU0VSVCxcbiAgICAgICAgICAgICAgICAgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKSldO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cblxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXG4gICAgLy8gQWZ0ZXIgdGhlIHByZXZpb3VzIHNwZWVkdXAsIHRoZSBjaGFyYWN0ZXIgY2FuJ3QgYmUgYW4gZXF1YWxpdHkuXG4gICAgcmV0dXJuIFtuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCB0ZXh0MSksXG4gICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChobSkge1xuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICB2YXIgZGlmZnNfYiA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2IsIHRleHQyX2IsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW25ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgbWlkX2NvbW1vbildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc19iKTtcbiAgfVxuXG4gIGlmIChjaGVja2xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmX2xpbmVNb2RlXyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0Xyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcbn07XG5cblxuLyoqXG4gKiBEbyBhIHF1aWNrIGxpbmUtbGV2ZWwgZGlmZiBvbiBib3RoIHN0cmluZ3MsIHRoZW4gcmVkaWZmIHRoZSBwYXJ0cyBmb3JcbiAqIGdyZWF0ZXIgYWNjdXJhY3kuXG4gKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZSBieS5cbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lTW9kZV8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gIC8vIFNjYW4gdGhlIHRleHQgb24gYSBsaW5lLWJ5LWxpbmUgYmFzaXMgZmlyc3QuXG4gIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc18odGV4dDEsIHRleHQyKTtcbiAgdGV4dDEgPSBhLmNoYXJzMTtcbiAgdGV4dDIgPSBhLmNoYXJzMjtcbiAgdmFyIGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xuXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UsIGRlYWRsaW5lKTtcblxuICAvLyBDb252ZXJ0IHRoZSBkaWZmIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC5cbiAgdGhpcy5kaWZmX2NoYXJzVG9MaW5lc18oZGlmZnMsIGxpbmVhcnJheSk7XG4gIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcblxuICAvLyBSZWRpZmYgYW55IHJlcGxhY2VtZW50IGJsb2NrcywgdGhpcyB0aW1lIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXG4gIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIGRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCAnJykpO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcbiAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50X2luc2VydCsrO1xuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlID49IDEgJiYgY291bnRfaW5zZXJ0ID49IDEpIHtcbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0O1xuICAgICAgICAgIHZhciBzdWJEaWZmID1cbiAgICAgICAgICAgICAgdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSwgZGVhZGxpbmUpO1xuICAgICAgICAgIGZvciAodmFyIGogPSBzdWJEaWZmLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgc3ViRGlmZltqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgc3ViRGlmZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cblxuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgJ21pZGRsZSBzbmFrZScgb2YgYSBkaWZmLCBzcGxpdCB0aGUgcHJvYmxlbSBpbiB0d29cbiAqIGFuZCByZXR1cm4gdGhlIHJlY3Vyc2l2ZWx5IGNvbnN0cnVjdGVkIGRpZmYuXG4gKiBTZWUgTXllcnMgMTk4NiBwYXBlcjogQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIEl0cyBWYXJpYXRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdF8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gIHZhciB2X29mZnNldCA9IG1heF9kO1xuICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIHZhciBkZWx0YSA9IHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aDtcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuICB2YXIgZnJvbnQgPSAoZGVsdGEgJSAyICE9IDApO1xuICAvLyBPZmZzZXRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGsgbG9vcC5cbiAgLy8gUHJldmVudHMgbWFwcGluZyBvZiBzcGFjZSBiZXlvbmQgdGhlIGdyaWQuXG4gIHZhciBrMXN0YXJ0ID0gMDtcbiAgdmFyIGsxZW5kID0gMDtcbiAgdmFyIGsyc3RhcnQgPSAwO1xuICB2YXIgazJlbmQgPSAwO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcbiAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxuICAgIGlmICgobmV3IERhdGUoKSkuZ2V0VGltZSgpID4gZGVhZGxpbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdhbGsgdGhlIGZyb250IHBhdGggb25lIHN0ZXAuXG4gICAgZm9yICh2YXIgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgazE7XG4gICAgICB2YXIgeDE7XG4gICAgICBpZiAoazEgPT0gLWQgfHwgKGsxICE9IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkxID0geDEgLSBrMTtcbiAgICAgIHdoaWxlICh4MSA8IHRleHQxX2xlbmd0aCAmJiB5MSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh4MSkgPT0gdGV4dDIuY2hhckF0KHkxKSkge1xuICAgICAgICB4MSsrO1xuICAgICAgICB5MSsrO1xuICAgICAgfVxuICAgICAgdjFbazFfb2Zmc2V0XSA9IHgxO1xuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHJpZ2h0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTEgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJfb2Zmc2V0ID49IDAgJiYgazJfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjJbazJfb2Zmc2V0XSAhPSAtMSkge1xuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgIHZhciB4MiA9IHRleHQxX2xlbmd0aCAtIHYyW2syX29mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgZm9yICh2YXIgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xuICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XG4gICAgICB2YXIgeDI7XG4gICAgICBpZiAoazIgPT0gLWQgfHwgKGsyICE9IGQgJiYgdjJbazJfb2Zmc2V0IC0gMV0gPCB2MltrMl9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkyID0geDIgLSBrMjtcbiAgICAgIHdoaWxlICh4MiA8IHRleHQxX2xlbmd0aCAmJiB5MiA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MV9sZW5ndGggLSB4MiAtIDEpID09XG4gICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkyIC0gMSkpIHtcbiAgICAgICAgeDIrKztcbiAgICAgICAgeTIrKztcbiAgICAgIH1cbiAgICAgIHYyW2syX29mZnNldF0gPSB4MjtcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBsZWZ0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgdG9wIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxX29mZnNldCA+PSAwICYmIGsxX29mZnNldCA8IHZfbGVuZ3RoICYmIHYxW2sxX29mZnNldF0gIT0gLTEpIHtcbiAgICAgICAgICB2YXIgeDEgPSB2MVtrMV9vZmZzZXRdO1xuICAgICAgICAgIHZhciB5MSA9IHZfb2Zmc2V0ICsgeDEgLSBrMV9vZmZzZXQ7XG4gICAgICAgICAgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAgeDIgPSB0ZXh0MV9sZW5ndGggLSB4MjtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaWZmIHRvb2sgdG9vIGxvbmcgYW5kIGhpdCB0aGUgZGVhZGxpbmUgb3JcbiAgLy8gbnVtYmVyIG9mIGRpZmZzIGVxdWFscyBudW1iZXIgb2YgY2hhcmFjdGVycywgbm8gY29tbW9uYWxpdHkgYXQgYWxsLlxuICByZXR1cm4gW25ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9ERUxFVEUsIHRleHQxKSxcbiAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIHRoZSBsb2NhdGlvbiBvZiB0aGUgJ21pZGRsZSBzbmFrZScsIHNwbGl0IHRoZSBkaWZmIGluIHR3byBwYXJ0c1xuICogYW5kIHJlY3Vyc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdFNwbGl0XyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgeCwgeSxcbiAgICBkZWFkbGluZSkge1xuICB2YXIgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpO1xuICB2YXIgdGV4dDJhID0gdGV4dDIuc3Vic3RyaW5nKDAsIHkpO1xuICB2YXIgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpO1xuICB2YXIgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpO1xuXG4gIC8vIENvbXB1dGUgYm90aCBkaWZmcyBzZXJpYWxseS5cbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDFhLCB0ZXh0MmEsIGZhbHNlLCBkZWFkbGluZSk7XG4gIHZhciBkaWZmc2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MWIsIHRleHQyYiwgZmFsc2UsIGRlYWRsaW5lKTtcblxuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59O1xuXG5cbi8qKlxuICogU3BsaXQgdHdvIHRleHRzIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcbiAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHt7Y2hhcnMxOiBzdHJpbmcsIGNoYXJzMjogc3RyaW5nLCBsaW5lQXJyYXk6ICFBcnJheS48c3RyaW5nPn19XG4gKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZFxuICogICAgIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cbiAqICAgICBUaGUgemVyb3RoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzIGlzIGludGVudGlvbmFsbHkgYmxhbmsuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xpbmVzVG9DaGFyc18gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxpbmVBcnJheSA9IFtdOyAgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xuICB2YXIgbGluZUhhc2ggPSB7fTsgICAvLyBlLmcuIGxpbmVIYXNoWydIZWxsb1xcbiddID09IDRcblxuICAvLyAnXFx4MDAnIGlzIGEgdmFsaWQgY2hhcmFjdGVyLCBidXQgdmFyaW91cyBkZWJ1Z2dlcnMgZG9uJ3QgbGlrZSBpdC5cbiAgLy8gU28gd2UnbGwgaW5zZXJ0IGEganVuayBlbnRyeSB0byBhdm9pZCBnZW5lcmF0aW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG4gIGxpbmVBcnJheVswXSA9ICcnO1xuXG4gIC8qKlxuICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICAgKiBNb2RpZmllcyBsaW5lYXJyYXkgYW5kIGxpbmVoYXNoIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dCkge1xuICAgIHZhciBjaGFycyA9ICcnO1xuICAgIC8vIFdhbGsgdGhlIHRleHQsIHB1bGxpbmcgb3V0IGEgc3Vic3RyaW5nIGZvciBlYWNoIGxpbmUuXG4gICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxuICAgIC8vIE1vZGlmeWluZyB0ZXh0IHdvdWxkIGNyZWF0ZSBtYW55IGxhcmdlIHN0cmluZ3MgdG8gZ2FyYmFnZSBjb2xsZWN0LlxuICAgIHZhciBsaW5lU3RhcnQgPSAwO1xuICAgIHZhciBsaW5lRW5kID0gLTE7XG4gICAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXJpYWJsZSBpcyBmYXN0ZXIgdGhhbiBsb29raW5nIGl0IHVwLlxuICAgIHZhciBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKCdcXG4nLCBsaW5lU3RhcnQpO1xuICAgICAgaWYgKGxpbmVFbmQgPT0gLTEpIHtcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG5cbiAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDpcbiAgICAgICAgICAobGluZUhhc2hbbGluZV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lSGFzaFtsaW5lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZUFycmF5TGVuZ3RoID09IG1heExpbmVzKSB7XG4gICAgICAgICAgLy8gQmFpbCBvdXQgYXQgNjU1MzUgYmVjYXVzZVxuICAgICAgICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzYpID09IFN0cmluZy5mcm9tQ2hhckNvZGUoMClcbiAgICAgICAgICBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0KTtcbiAgICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICB9XG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9XG4gIC8vIEFsbG9jYXRlIDIvM3JkcyBvZiB0aGUgc3BhY2UgZm9yIHRleHQxLCB0aGUgcmVzdCBmb3IgdGV4dDIuXG4gIHZhciBtYXhMaW5lcyA9IDQwMDAwO1xuICB2YXIgY2hhcnMxID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICB2YXIgY2hhcnMyID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDIpO1xuICByZXR1cm4ge2NoYXJzMTogY2hhcnMxLCBjaGFyczI6IGNoYXJzMiwgbGluZUFycmF5OiBsaW5lQXJyYXl9O1xufTtcblxuXG4vKipcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG4gKiB0ZXh0LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lc18gPSBmdW5jdGlvbihkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcnMgPSBkaWZmc1tpXVsxXTtcbiAgICB2YXIgdGV4dCA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRleHRbal0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdChqKV07XG4gICAgfVxuICAgIGRpZmZzW2ldWzFdID0gdGV4dC5qb2luKCcnKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICogICAgIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25QcmVmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25TdWZmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fFxuICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc3VmZml4IG9mIG9uZSBzdHJpbmcgaXMgdGhlIHByZWZpeCBvZiBhbm90aGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0XG4gKiAgICAgc3RyaW5nIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHNlY29uZCBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vbk92ZXJsYXBfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgLy8gRWxpbWluYXRlIHRoZSBudWxsIGNhc2UuXG4gIGlmICh0ZXh0MV9sZW5ndGggPT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIFRydW5jYXRlIHRoZSBsb25nZXIgc3RyaW5nLlxuICBpZiAodGV4dDFfbGVuZ3RoID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0ZXh0MV9sZW5ndGggPCB0ZXh0Ml9sZW5ndGgpIHtcbiAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGgpO1xuICB9XG4gIHZhciB0ZXh0X2xlbmd0aCA9IE1hdGgubWluKHRleHQxX2xlbmd0aCwgdGV4dDJfbGVuZ3RoKTtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIHRoZSB3b3JzdCBjYXNlLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICByZXR1cm4gdGV4dF9sZW5ndGg7XG4gIH1cblxuICAvLyBTdGFydCBieSBsb29raW5nIGZvciBhIHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hcbiAgLy8gYW5kIGluY3JlYXNlIGxlbmd0aCB1bnRpbCBubyBtYXRjaCBpcyBmb3VuZC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMTAvMTEvMDQvXG4gIHZhciBiZXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IDE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpO1xuICAgIHZhciBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG4gICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9XG4gICAgbGVuZ3RoICs9IGZvdW5kO1xuICAgIGlmIChmb3VuZCA9PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0X2xlbmd0aCAtIGxlbmd0aCkgPT1cbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpIHtcbiAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICBsZW5ndGgrKztcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIGxvbmdlciB0ZXh0P1xuICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfaGFsZk1hdGNoXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xuICAgIC8vIERvbid0IHJpc2sgcmV0dXJuaW5nIGEgbm9uLW9wdGltYWwgZGlmZiBpZiB3ZSBoYXZlIHVubGltaXRlZCB0aW1lLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ3RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydHRleHQubGVuZ3RoICogMiA8IGxvbmd0ZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxuICB9XG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0LlxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBpKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuICAgIHZhciBzZWVkID0gbG9uZ3RleHQuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgICB2YXIgaiA9IC0xO1xuICAgIHZhciBiZXN0X2NvbW1vbiA9ICcnO1xuICAgIHZhciBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcbiAgICB3aGlsZSAoKGogPSBzaG9ydHRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9IC0xKSB7XG4gICAgICB2YXIgcHJlZml4TGVuZ3RoID0gZG1wLmRpZmZfY29tbW9uUHJlZml4KGxvbmd0ZXh0LnN1YnN0cmluZyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqKSk7XG4gICAgICB2YXIgc3VmZml4TGVuZ3RoID0gZG1wLmRpZmZfY29tbW9uU3VmZml4KGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqKSk7XG4gICAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XG4gICAgICAgIGJlc3RfY29tbW9uID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqIC0gc3VmZml4TGVuZ3RoLCBqKSArXG4gICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGosIGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EgPSBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaiAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2IgPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsXG4gICAgICAgICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2IsIGJlc3RfY29tbW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHNlY29uZCBxdWFydGVyIGlzIHRoZSBzZWVkIGZvciBhIGhhbGYtbWF0Y2guXG4gIHZhciBobTEgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMikpO1xuICB2YXIgaG07XG4gIGlmICghaG0xICYmICFobTIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICghaG0yKSB7XG4gICAgaG0gPSBobTE7XG4gIH0gZWxzZSBpZiAoIWhtMSkge1xuICAgIGhtID0gaG0yO1xuICB9IGVsc2Uge1xuICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICB9XG5cbiAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgcmV0dXJuIFt0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iLCBtaWRfY29tbW9uXTtcbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWMgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gIHZhciBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBwcmlvciB0byB0aGUgZXF1YWxpdHkuXG4gIHZhciBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwO1xuICB2YXIgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgYWZ0ZXIgdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgdmFyIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gRXF1YWxpdHkgZm91bmQuXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gbGVuZ3RoX2luc2VydGlvbnMyO1xuICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSBsZW5ndGhfZGVsZXRpb25zMjtcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICB9IGVsc2UgeyAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBFbGltaW5hdGUgYW4gZXF1YWxpdHkgdGhhdCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBlZGl0cyBvbiBib3RoXG4gICAgICAvLyBzaWRlcyBvZiBpdC5cbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgKGxhc3RFcXVhbGl0eS5sZW5ndGggPD1cbiAgICAgICAgICBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczEsIGxlbmd0aF9kZWxldGlvbnMxKSkgJiZcbiAgICAgICAgICAobGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHkpKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcbiAgICAgICAgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZGlmZi5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuXG4gIC8vIEZpbmQgYW55IG92ZXJsYXBzIGJldHdlZW4gZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zLlxuICAvLyBlLmc6IDxkZWw+YWJjeHh4PC9kZWw+PGlucz54eHhkZWY8L2lucz5cbiAgLy8gICAtPiA8ZGVsPmFiYzwvZGVsPnh4eDxpbnM+ZGVmPC9pbnM+XG4gIC8vIGUuZzogPGRlbD54eHhhYmM8L2RlbD48aW5zPmRlZnh4eDwvaW5zPlxuICAvLyAgIC0+IDxpbnM+ZGVmPC9pbnM+eHh4PGRlbD5hYmM8L2RlbD5cbiAgLy8gT25seSBleHRyYWN0IGFuIG92ZXJsYXAgaWYgaXQgaXMgYXMgYmlnIGFzIHRoZSBlZGl0IGFoZWFkIG9yIGJlaGluZCBpdC5cbiAgcG9pbnRlciA9IDE7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0RFTEVURSAmJlxuICAgICAgICBkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0lOU0VSVCkge1xuICAgICAgdmFyIGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgdmFyIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgdmFyIG92ZXJsYXBfbGVuZ3RoMSA9IHRoaXMuZGlmZl9jb21tb25PdmVybGFwXyhkZWxldGlvbiwgaW5zZXJ0aW9uKTtcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDIgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IG92ZXJsYXBfbGVuZ3RoMikge1xuICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcbiAgICAgICAgICAgIG92ZXJsYXBfbGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgIC8vIE92ZXJsYXAgZm91bmQuICBJbnNlcnQgYW4gZXF1YWxpdHkgYW5kIHRyaW0gdGhlIHN1cnJvdW5kaW5nIGVkaXRzLlxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfRVFVQUwsXG4gICAgICAgICAgICAgIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgxKSkpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9XG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgxKTtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fFxuICAgICAgICAgICAgb3ZlcmxhcF9sZW5ndGgyID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XG4gICAgICAgICAgLy8gUmV2ZXJzZSBvdmVybGFwIGZvdW5kLlxuICAgICAgICAgIC8vIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgc3dhcCBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBfbGVuZ3RoMikpKTtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPVxuICAgICAgICAgICAgICBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIGluc2VydGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDIpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERJRkZfREVMRVRFO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9XG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDIpO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIC8qKlxuICAgKiBHaXZlbiB0d28gc3RyaW5ncywgY29tcHV0ZSBhIHNjb3JlIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBpbnRlcm5hbFxuICAgKiBib3VuZGFyeSBmYWxscyBvbiBsb2dpY2FsIGJvdW5kYXJpZXMuXG4gICAqIFNjb3JlcyByYW5nZSBmcm9tIDYgKGJlc3QpIHRvIDAgKHdvcnN0KS5cbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgcmV0dXJuIDY7XG4gICAgfVxuXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cbiAgICAvLyBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gZWFjaCBsYW5ndWFnZSdzIGRlZmluaXRpb24gb2YgdGhpbmdzIGxpa2VcbiAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xuICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXG4gICAgdmFyIGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGNoYXIyID0gdHdvLmNoYXJBdCgwKTtcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfKTtcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMiA9IGNoYXIyLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfKTtcbiAgICB2YXIgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmXG4gICAgICAgIGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gud2hpdGVzcGFjZVJlZ2V4Xyk7XG4gICAgdmFyIHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJlxuICAgICAgICBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8pO1xuICAgIHZhciBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiZcbiAgICAgICAgY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8pO1xuICAgIHZhciBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiZcbiAgICAgICAgY2hhcjIubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8pO1xuICAgIHZhciBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJlxuICAgICAgICBvbmUubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVFbmRSZWdleF8pO1xuICAgIHZhciBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJlxuICAgICAgICB0d28ubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVTdGFydFJlZ2V4Xyk7XG5cbiAgICBpZiAoYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyKSB7XG4gICAgICAvLyBGaXZlIHBvaW50cyBmb3IgYmxhbmsgbGluZXMuXG4gICAgICByZXR1cm4gNTtcbiAgICB9IGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xuICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGxpbmUgYnJlYWtzLlxuICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xuICAgICAgLy8gVGhyZWUgcG9pbnRzIGZvciBlbmQgb2Ygc2VudGVuY2VzLlxuICAgICAgcmV0dXJuIDM7XG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMikge1xuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyKSB7XG4gICAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgdmFyIGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB2YXIgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICB2YXIgY29tbW9uT2Zmc2V0ID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgIHZhciBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcbiAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgdmFyIHNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZXF1YWxpdHkxLCBlZGl0KSArXG4gICAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXG4gICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpIHtcbiAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgICAgIGJlc3RFZGl0ID0gZWRpdDtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT0gYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIGltcHJvdmVtZW50LCBzYXZlIGl0IGJhY2sgdG8gdGhlIGRpZmYuXG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0O1xuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5Mikge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG59O1xuXG4vLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cbmRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfID0gL1teYS16QS1aMC05XS87XG5kaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8gPSAvXFxzLztcbmRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfID0gL1tcXHJcXG5dLztcbmRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lRW5kUmVnZXhfID0gL1xcblxccj9cXG4kLztcbmRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lU3RhcnRSZWdleF8gPSAvXlxccj9cXG5cXHI/XFxuLztcblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cEVmZmljaWVuY3kgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gIHZhciBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcHJlX2lucyA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwcmVfZGVsID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwb3N0X2lucyA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHBvc3RfZGVsID0gZmFsc2U7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIEVxdWFsaXR5IGZvdW5kLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxuICAgICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcbiAgICAgICAgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYSBjYW5kaWRhdGUsIGFuZCBjYW4gbmV2ZXIgYmVjb21lIG9uZS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICB9XG4gICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgfSBlbHNlIHsgIC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0RFTEVURSkge1xuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlhZPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XG4gICAgICAgKiA8aW5zPkE8L2RlbD5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgKChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxhc3RFcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVfaW5zICsgcHJlX2RlbCArIHBvc3RfaW5zICsgcG9zdF9kZWwpID09IDMpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHkpKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07ICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQ7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cblxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwTWVyZ2UgPSBmdW5jdGlvbihkaWZmcykge1xuICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICBkaWZmcy5wdXNoKG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgJycpKTtcbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQgPiAxKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCkpKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICBwb2ludGVyIC09IGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydDtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0KTtcbiAgICAgICAgICBpZiAodGV4dF9kZWxldGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcbiAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZSkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dF9pbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcbiAgICAgICAgICAgICAgICBuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCB0ZXh0X2luc2VydCkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIC8vIE1lcmdlIHRoaXMgZXF1YWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgIHRleHRfZGVsZXRlID0gJyc7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09ICcnKSB7XG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIH1cblxuICAvLyBTZWNvbmQgcGFzczogbG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXG4gIC8vIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGVsaW1pbmF0ZSBhbiBlcXVhbGl0eS5cbiAgLy8gZS5nOiBBPGlucz5CQTwvaW5zPkMgLT4gPGlucz5BQjwvaW5zPkFDXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHBvaW50ZXIgPSAxO1xuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICtcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpO1xuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT1cbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgbmV4dCBlcXVhbGl0eS5cbiAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPVxuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICAvLyBJZiBzaGlmdHMgd2VyZSBtYWRlLCB0aGUgZGlmZiBuZWVkcyByZW9yZGVyaW5nIGFuZCBhbm90aGVyIHNoaWZ0IHN3ZWVwLlxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogbG9jIGlzIGEgbG9jYXRpb24gaW4gdGV4dDEsIGNvbXB1dGUgYW5kIHJldHVybiB0aGUgZXF1aXZhbGVudCBsb2NhdGlvbiBpblxuICogdGV4dDIuXG4gKiBlLmcuICdUaGUgY2F0JyB2cyAnVGhlIGJpZyBjYXQnLCAxLT4xLCA1LT44XG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvY2F0aW9uIHdpdGhpbiB0ZXh0Mi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl94SW5kZXggPSBmdW5jdGlvbihkaWZmcywgbG9jKSB7XG4gIHZhciBjaGFyczEgPSAwO1xuICB2YXIgY2hhcnMyID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMyID0gMDtcbiAgdmFyIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHsgIC8vIEVxdWFsaXR5IG9yIGRlbGV0aW9uLlxuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkgeyAgLy8gRXF1YWxpdHkgb3IgaW5zZXJ0aW9uLlxuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGNoYXJzMSA+IGxvYykgeyAgLy8gT3ZlcnNob3QgdGhlIGxvY2F0aW9uLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICB9XG4gIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIH1cbiAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlmZiBhcnJheSBpbnRvIGEgcHJldHR5IEhUTUwgcmVwb3J0LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGh0bWwgPSBbXTtcbiAgdmFyIHBhdHRlcm5fYW1wID0gLyYvZztcbiAgdmFyIHBhdHRlcm5fbHQgPSAvPC9nO1xuICB2YXIgcGF0dGVybl9ndCA9IC8+L2c7XG4gIHZhciBwYXR0ZXJuX3BhcmEgPSAvXFxuL2c7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTsgICAgLy8gT3BlcmF0aW9uIChpbnNlcnQsIGRlbGV0ZSwgZXF1YWwpXG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTsgIC8vIFRleHQgb2YgY2hhbmdlLlxuICAgIHZhciB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCAnJmFtcDsnKS5yZXBsYWNlKHBhdHRlcm5fbHQsICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UocGF0dGVybl9ndCwgJyZndDsnKS5yZXBsYWNlKHBhdHRlcm5fcGFyYSwgJyZwYXJhOzxicj4nKTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBodG1sW3hdID0gJzxpbnMgc3R5bGU9XCJiYWNrZ3JvdW5kOiNlNmZmZTY7XCI+JyArIHRleHQgKyAnPC9pbnM+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBodG1sW3hdID0gJzxkZWwgc3R5bGU9XCJiYWNrZ3JvdW5kOiNmZmU2ZTY7XCI+JyArIHRleHQgKyAnPC9kZWw+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGh0bWxbeF0gPSAnPHNwYW4+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNvdXJjZSB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgZGVsZXRpb25zKS5cbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQxID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgaW5zZXJ0aW9ucykuXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcbiAqIHN1YnN0aXR1dGVkIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgY2hhbmdlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9sZXZlbnNodGVpbiA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBsZXZlbnNodGVpbiA9IDA7XG4gIHZhciBpbnNlcnRpb25zID0gMDtcbiAgdmFyIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTtcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdO1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgLy8gQSBkZWxldGlvbiBhbmQgYW4gaW5zZXJ0aW9uIGlzIG9uZSBzdWJzdGl0dXRpb24uXG4gICAgICAgIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gICAgICAgIGluc2VydGlvbnMgPSAwO1xuICAgICAgICBkZWxldGlvbnMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgcmV0dXJuIGxldmVuc2h0ZWluO1xufTtcblxuXG4vKipcbiAqIENydXNoIHRoZSBkaWZmIGludG8gYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSBvcGVyYXRpb25zXG4gKiByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0Mi5cbiAqIEUuZy4gPTNcXHQtMlxcdCtpbmcgIC0+IEtlZXAgMyBjaGFycywgZGVsZXRlIDIgY2hhcnMsIGluc2VydCAnaW5nJy5cbiAqIE9wZXJhdGlvbnMgYXJlIHRhYi1zZXBhcmF0ZWQuICBJbnNlcnRlZCB0ZXh0IGlzIGVzY2FwZWQgdXNpbmcgJXh4IG5vdGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRGVsdGEgdGV4dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90b0RlbHRhID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAoZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHRleHRbeF0gPSAnLScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignXFx0JykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxuICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIFNvdXJjZSBzdHJpbmcgZm9yIHRoZSBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEB0aHJvd3MgeyFFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbih0ZXh0MSwgZGVsdGEpIHtcbiAgdmFyIGRpZmZzID0gW107XG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEN1cnNvciBpbiB0ZXh0MVxuICB2YXIgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcbiAgICAvLyBFYWNoIHRva2VuIGJlZ2lucyB3aXRoIGEgb25lIGNoYXJhY3RlciBwYXJhbWV0ZXIgd2hpY2ggc3BlY2lmaWVzIHRoZVxuICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxuICAgIHZhciBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9JTlNFUlQsIGRlY29kZVVSSShwYXJhbSkpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgdmFyIG4gPSBwYXJzZUludChwYXJhbSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09ICc9Jykge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCB0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9ERUxFVEUsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQmxhbmsgdG9rZW5zIGFyZSBvayAoZnJvbSBhIHRyYWlsaW5nIFxcdCkuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYW4gZXJyb3IuXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbeF0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVsdGEgbGVuZ3RoICgnICsgcG9pbnRlciArXG4gICAgICAgICcpIGRvZXMgbm90IGVxdWFsIHNvdXJjZSB0ZXh0IGxlbmd0aCAoJyArIHRleHQxLmxlbmd0aCArICcpLicpO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLy8gIE1BVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xuICB9XG5cbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xuICBpZiAodGV4dCA9PSBwYXR0ZXJuKSB7XG4gICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaC5cbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xuICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcbiAgICByZXR1cm4gbG9jO1xuICB9IGVsc2Uge1xuICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcF8odGV4dCwgcGF0dGVybiwgbG9jKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXG4gKiBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwXyA9IGZ1bmN0aW9uKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci4nKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0LlxuICB2YXIgcyA9IHRoaXMubWF0Y2hfYWxwaGFiZXRfKHBhdHRlcm4pO1xuXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXG4gICAqIEFjY2Vzc2VzIGxvYyBhbmQgcGF0dGVybiB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTG9jYXRpb24gb2YgbWF0Y2guXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3ZlcmFsbCBzY29yZSBmb3IgbWF0Y2ggKDAuMCA9IGdvb2QsIDEuMCA9IGJhZCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaF9iaXRhcFNjb3JlXyhlLCB4KSB7XG4gICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xuICAgIHZhciBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICBpZiAoIWRtcC5NYXRjaF9EaXN0YW5jZSkge1xuICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG4gICAgfVxuICAgIHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBkbXAuTWF0Y2hfRGlzdGFuY2UpO1xuICB9XG5cbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgdmFyIHNjb3JlX3RocmVzaG9sZCA9IHRoaXMuTWF0Y2hfVGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIHZhciBiZXN0X2xvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgLy8gV2hhdCBhYm91dCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uPyAoc3BlZWR1cClcbiAgICBiZXN0X2xvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpO1xuICAgIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgICAgc2NvcmVfdGhyZXNob2xkID1cbiAgICAgICAgICBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gIGJlc3RfbG9jID0gLTE7XG5cbiAgdmFyIGJpbl9taW4sIGJpbl9taWQ7XG4gIHZhciBiaW5fbWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcbiAgdmFyIGxhc3RfcmQ7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xuICAgIC8vIGVycm9yIGxldmVsLlxuICAgIGJpbl9taW4gPSAwO1xuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xuICAgICAgaWYgKG1hdGNoX2JpdGFwU2NvcmVfKGQsIGxvYyArIGJpbl9taWQpIDw9IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICBiaW5fbWluID0gYmluX21pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgfVxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xuICAgIHZhciBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcblxuICAgIHZhciByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgLy8gVGhlIGFscGhhYmV0IChzKSBpcyBhIHNwYXJzZSBoYXNoLCBzbyB0aGUgZm9sbG93aW5nIGxpbmUgZ2VuZXJhdGVzXG4gICAgICAvLyB3YXJuaW5ncy5cbiAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCkgeyAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcbiAgICAgIH0gZWxzZSB7ICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKCgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2gpIHxcbiAgICAgICAgICAgICAgICAoKChsYXN0X3JkW2ogKyAxXSB8IGxhc3RfcmRbal0pIDw8IDEpIHwgMSkgfFxuICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmVfKGQsIGogLSAxKTtcbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gVG9sZCB5b3Ugc28uXG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgbG9jLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCArIDEsIGxvYykgPiBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYXN0X3JkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RfbG9jO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0IGZvciB0aGUgQml0YXAgYWxnb3JpdGhtLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHRleHQgdG8gZW5jb2RlLlxuICogQHJldHVybiB7IU9iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYWxwaGFiZXRfID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG5cbi8vICBQQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIEluY3JlYXNlIHRoZSBjb250ZXh0IHVudGlsIGl0IGlzIHVuaXF1ZSxcbiAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxuICogQHBhcmFtIHshZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmp9IHBhdGNoIFRoZSBwYXRjaCB0byBncm93LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU291cmNlIHRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0XyA9IGZ1bmN0aW9uKHBhdGNoLCB0ZXh0KSB7XG4gIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXRjaC5zdGFydDIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcigncGF0Y2ggbm90IGluaXRpYWxpemVkJyk7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpO1xuICB2YXIgcGFkZGluZyA9IDA7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IG1hdGNoZXMgb2YgcGF0dGVybiBpbiB0ZXh0LiAgSWYgdHdvIGRpZmZlcmVudFxuICAvLyBtYXRjaGVzIGFyZSBmb3VuZCwgaW5jcmVhc2UgdGhlIHBhdHRlcm4gbGVuZ3RoLlxuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcbiAgICAgICAgIHBhdHRlcm4ubGVuZ3RoIDwgdGhpcy5NYXRjaF9NYXhCaXRzIC0gdGhpcy5QYXRjaF9NYXJnaW4gLVxuICAgICAgICAgdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgLy8gQWRkIG9uZSBjaHVuayBmb3IgZ29vZCBsdWNrLlxuICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuXG4gIC8vIEFkZCB0aGUgcHJlZml4LlxuICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeCkge1xuICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBwcmVmaXgpKTtcbiAgfVxuICAvLyBBZGQgdGhlIHN1ZmZpeC5cbiAgdmFyIHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIGlmIChzdWZmaXgpIHtcbiAgICBwYXRjaC5kaWZmcy5wdXNoKG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgc3VmZml4KSk7XG4gIH1cblxuICAvLyBSb2xsIGJhY2sgdGhlIHN0YXJ0IHBvaW50cy5cbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeC5sZW5ndGg7XG4gIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXgubGVuZ3RoO1xuICAvLyBFeHRlbmQgdGhlIGxlbmd0aHMuXG4gIHBhdGNoLmxlbmd0aDEgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG4gIHBhdGNoLmxlbmd0aDIgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhIGxpc3Qgb2YgcGF0Y2hlcyB0byB0dXJuIHRleHQxIGludG8gdGV4dDIuXG4gKiBVc2UgZGlmZnMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBjb21wdXRlIGl0IG91cnNlbHZlcy5cbiAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXG4gKiBhdmFpbGFibGUgdG8gdGhlIGNhbGxlcjpcbiAqIE1ldGhvZCAxOlxuICogYSA9IHRleHQxLCBiID0gdGV4dDJcbiAqIE1ldGhvZCAyOlxuICogYSA9IGRpZmZzXG4gKiBNZXRob2QgMyAob3B0aW1hbCk6XG4gKiBhID0gdGV4dDEsIGIgPSBkaWZmc1xuICogTWV0aG9kIDQgKGRlcHJlY2F0ZWQsIHVzZSBtZXRob2QgMyk6XG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gYSB0ZXh0MSAobWV0aG9kcyAxLDMsNCkgb3JcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDIpLlxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPj19IG9wdF9iIHRleHQyIChtZXRob2RzIDEsNCkgb3JcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDMpIG9yIHVuZGVmaW5lZCAobWV0aG9kIDIpLlxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPj19IG9wdF9jIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCA0KSBvciB1bmRlZmluZWQgKG1ldGhvZHMgMSwyLDMpLlxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24oYSwgb3B0X2IsIG9wdF9jKSB7XG4gIHZhciB0ZXh0MSwgZGlmZnM7XG4gIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcbiAgICAvLyBDb21wdXRlIGRpZmZzIGZyb20gdGV4dDEgYW5kIHRleHQyLlxuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovKGEpO1xuICAgIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDEsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhvcHRfYiksIHRydWUpO1xuICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdF9iID09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBNZXRob2QgMjogZGlmZnNcbiAgICAvLyBDb21wdXRlIHRleHQxIGZyb20gZGlmZnMuXG4gICAgZGlmZnMgPSAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovKGEpO1xuICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiBvcHRfYiAmJiB0eXBlb2Ygb3B0X2IgPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAzOiB0ZXh0MSwgZGlmZnNcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8ob3B0X2IpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRfYiA9PSAnc3RyaW5nJyAmJlxuICAgICAgb3B0X2MgJiYgdHlwZW9mIG9wdF9jID09ICdvYmplY3QnKSB7XG4gICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcbiAgICAvLyB0ZXh0MiBpcyBub3QgdXNlZC5cbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8ob3B0X2MpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYWxsIGZvcm1hdCB0byBwYXRjaF9tYWtlLicpO1xuICB9XG5cbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTsgIC8vIEdldCByaWQgb2YgdGhlIG51bGwgY2FzZS5cbiAgfVxuICB2YXIgcGF0Y2hlcyA9IFtdO1xuICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcbiAgdmFyIHBhdGNoRGlmZkxlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXG4gIHZhciBjaGFyX2NvdW50MiA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XG4gIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxuICAvLyBjb250ZXh0IGluZm8uXG4gIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGRpZmZfdHlwZSA9IGRpZmZzW3hdWzBdO1xuICAgIHZhciBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcblxuICAgIGlmICghcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZfdHlwZSAhPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gQSBuZXcgcGF0Y2ggc3RhcnRzIGhlcmUuXG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiB0aGlzLlBhdGNoX01hcmdpbiAmJlxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xuICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHRfKHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIFVubGlrZSBVbmlkaWZmLCBvdXIgcGF0Y2ggbGlzdHMgaGF2ZSBhIHJvbGxpbmcgY29udGV4dC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZGlmZi1tYXRjaC1wYXRjaC93aWtpL1VuaWRpZmZcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgLy8ganVzdCBjb21wbGV0ZWQgcGF0Y2guXG4gICAgICAgICAgICBwcmVwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQ7XG4gICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgfVxuXG4gIHJldHVybiBwYXRjaGVzO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHBhdGNoZXMsIHJldHVybiBhbm90aGVyIGFycmF5IHRoYXQgaXMgaWRlbnRpY2FsLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZGVlcENvcHkgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIC8vIE1ha2luZyBkZWVwIGNvcGllcyBpcyBoYXJkIGluIEphdmFTY3JpcHQuXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPVxuICAgICAgICAgIG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYocGF0Y2guZGlmZnNbeV1bMF0sIHBhdGNoLmRpZmZzW3ldWzFdKTtcbiAgICB9XG4gICAgcGF0Y2hDb3B5LnN0YXJ0MSA9IHBhdGNoLnN0YXJ0MTtcbiAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xuICAgIHBhdGNoQ29weS5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMTtcbiAgICBwYXRjaENvcHkubGVuZ3RoMiA9IHBhdGNoLmxlbmd0aDI7XG4gICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXNDb3B5O1xufTtcblxuXG4vKipcbiAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgT2xkIHRleHQuXG4gKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZ3whQXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbihwYXRjaGVzLCB0ZXh0KSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIH1cblxuICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cbiAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XG5cbiAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG5cbiAgdGhpcy5wYXRjaF9zcGxpdE1heChwYXRjaGVzKTtcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSBwcmV2aW91cyBwYXRjaC4gIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcbiAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBleHBlY3RlZF9sb2MgPSBwYXRjaGVzW3hdLnN0YXJ0MiArIGRlbHRhO1xuICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICB2YXIgc3RhcnRfbG9jO1xuICAgIHZhciBlbmRfbG9jID0gLTE7XG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgLy8gcGF0Y2hfc3BsaXRNYXggd2lsbCBvbmx5IHByb3ZpZGUgYW4gb3ZlcnNpemVkIHBhdHRlcm4gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgIC8vIGEgbW9uc3RlciBkZWxldGUuXG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfbG9jKTtcbiAgICAgIGlmIChzdGFydF9sb2MgIT0gLTEpIHtcbiAgICAgICAgZW5kX2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LFxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xuICAgICAgICAgIC8vIENhbid0IGZpbmQgdmFsaWQgdHJhaWxpbmcgY29udGV4dC4gIERyb3AgdGhpcyBwYXRjaC5cbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XG4gICAgfVxuICAgIGlmIChzdGFydF9sb2MgPT0gLTEpIHtcbiAgICAgIC8vIE5vIG1hdGNoIGZvdW5kLiAgOihcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBkZWx0YSBmb3IgdGhpcyBmYWlsZWQgcGF0Y2ggZnJvbSBzdWJzZXF1ZW50IHBhdGNoZXMuXG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvdW5kIGEgbWF0Y2guICA6KVxuICAgICAgcmVzdWx0c1t4XSA9IHRydWU7XG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcbiAgICAgIHZhciB0ZXh0MjtcbiAgICAgIGlmIChlbmRfbG9jID09IC0xKSB7XG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIGVuZF9sb2MgKyB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcbiAgICAgICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXG4gICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW1wZXJmZWN0IG1hdGNoLiAgUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxuICAgICAgICAvLyBpbmRpY2VzLlxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cyAmJlxuICAgICAgICAgICAgdGhpcy5kaWZmX2xldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+XG4gICAgICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIFRoZSBlbmQgcG9pbnRzIG1hdGNoLCBidXQgdGhlIGNvbnRlbnQgaXMgdW5hY2NlcHRhYmx5IGJhZC5cbiAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICB2YXIgaW5kZXgxID0gMDtcbiAgICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2hlc1t4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgdmFyIG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kWzBdID09PSBESUZGX0lOU0VSVCkgeyAgLy8gSW5zZXJ0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGluZGV4Mik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufTtcblxuXG4vKipcbiAqIEFkZCBzb21lIHBhZGRpbmcgb24gdGV4dCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgZWRnZXMgY2FuIG1hdGNoIHNvbWV0aGluZy5cbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHBhZGRpbmcgc3RyaW5nIGFkZGVkIHRvIGVhY2ggc2lkZS5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkUGFkZGluZyA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgdmFyIHBhZGRpbmdMZW5ndGggPSB0aGlzLlBhdGNoX01hcmdpbjtcbiAgdmFyIG51bGxQYWRkaW5nID0gJyc7XG4gIGZvciAodmFyIHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykge1xuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIH1cblxuICAvLyBCdW1wIGFsbCB0aGUgcGF0Y2hlcyBmb3J3YXJkLlxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoZXNbeF0uc3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH1cblxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIHN0YXJ0IG9mIGZpcnN0IGRpZmYuXG4gIHZhciBwYXRjaCA9IHBhdGNoZXNbMF07XG4gIHZhciBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbMF1bMF0gIT0gRElGRl9FUVVBTCkge1xuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICBkaWZmcy51bnNoaWZ0KG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgbnVsbFBhZGRpbmcpKTtcbiAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gZW5kIG9mIGxhc3QgZGlmZi5cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBudWxsUGFkZGluZykpO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufTtcblxuXG4vKipcbiAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxuICogbGltaXQgb2YgdGhlIG1hdGNoIGFsZ29yaXRobS5cbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIHZhciBwYXRjaF9zaXplID0gdGhpcy5NYXRjaF9NYXhCaXRzO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoX3NpemUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIHZhciBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDE7XG4gICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcbiAgICB2YXIgcHJlY29udGV4dCA9ICcnO1xuICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcbiAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXG4gICAgICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHByZWNvbnRleHQgIT09ICcnKSB7XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBwcmVjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMSA8IHBhdGNoX3NpemUgLSB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgICAgICB2YXIgZGlmZl90eXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XG4gICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKTtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9ERUxFVEUgJiYgcGF0Y2guZGlmZnMubGVuZ3RoID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1swXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaF9zaXplKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhcmdlIGRlbGV0aW9uLiAgTGV0IGl0IHBhc3MgaW4gb25lIGNodW5rLlxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihkaWZmX3R5cGUsIGRpZmZfdGV4dCkpO1xuICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVsZXRpb24gb3IgZXF1YWxpdHkuICBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cbiAgICAgICAgICBkaWZmX3RleHQgPSBkaWZmX3RleHQuc3Vic3RyaW5nKDAsXG4gICAgICAgICAgICAgIHBhdGNoX3NpemUgLSBwYXRjaC5sZW5ndGgxIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKGRpZmZfdHlwZSwgZGlmZl90ZXh0KSk7XG4gICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxuICAgICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENvbXB1dGUgdGhlIGhlYWQgY29udGV4dCBmb3IgdGhlIG5leHQgcGF0Y2guXG4gICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcbiAgICAgIHByZWNvbnRleHQgPVxuICAgICAgICAgIHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgLy8gQXBwZW5kIHRoZSBlbmQgY29udGV4dCBmb3IgdGhpcyBwYXRjaC5cbiAgICAgIHZhciBwb3N0Y29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MShiaWdwYXRjaC5kaWZmcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBwb3N0Y29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2gobmV3IGRpZmZfbWF0Y2hfcGF0Y2guRGlmZihESUZGX0VRVUFMLCBwb3N0Y29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgIHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFRha2UgYSBsaXN0IG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgUGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0bGluZSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2Zyb21UZXh0ID0gZnVuY3Rpb24odGV4dGxpbmUpIHtcbiAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgaWYgKCF0ZXh0bGluZSkge1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xuICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICB2YXIgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xuICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdGNoIHN0cmluZzogJyArIHRleHRbdGV4dFBvaW50ZXJdKTtcbiAgICB9XG4gICAgdmFyIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuXG4gICAgcGF0Y2guc3RhcnQyID0gcGFyc2VJbnQobVszXSwgMTApO1xuICAgIGlmIChtWzRdID09PSAnJykge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xuICAgIH1cbiAgICB0ZXh0UG9pbnRlcisrO1xuXG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduID09ICctJykge1xuICAgICAgICAvLyBEZWxldGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfREVMRVRFLCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJysnKSB7XG4gICAgICAgIC8vIEluc2VydGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChuZXcgZGlmZl9tYXRjaF9wYXRjaC5EaWZmKERJRkZfSU5TRVJULCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJyAnKSB7XG4gICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKG5ldyBkaWZmX21hdGNoX3BhdGNoLkRpZmYoRElGRl9FUVVBTCwgbGluZSkpO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xuICAgICAgICAvLyBTdGFydCBvZiBuZXh0IHBhdGNoLlxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcbiAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV1RGP1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XG4gICAgICB9XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5kaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaiA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovXG4gIHRoaXMuZGlmZnMgPSBbXTtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB0aGlzLnN0YXJ0MSA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgdGhpcy5zdGFydDIgPSBudWxsO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGgxID0gMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMubGVuZ3RoMiA9IDA7XG59O1xuXG5cbi8qKlxuICogRW11bGF0ZSBHTlUgZGlmZidzIGZvcm1hdC5cbiAqIEhlYWRlcjogQEAgLTM4Miw4ICs0ODEsOSBAQFxuICogSW5kaWNlcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmoucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb29yZHMxLCBjb29yZHMyO1xuICBpZiAodGhpcy5sZW5ndGgxID09PSAwKSB7XG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgJywwJztcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT0gMSkge1xuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gIH0gZWxzZSB7XG4gICAgY29vcmRzMSA9ICh0aGlzLnN0YXJ0MSArIDEpICsgJywnICsgdGhpcy5sZW5ndGgxO1xuICB9XG4gIGlmICh0aGlzLmxlbmd0aDIgPT09IDApIHtcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAnLDAnO1xuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMiA9PSAxKSB7XG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZHMyID0gKHRoaXMuc3RhcnQyICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDI7XG4gIH1cbiAgdmFyIHRleHQgPSBbJ0BAIC0nICsgY29vcmRzMSArICcgKycgKyBjb29yZHMyICsgJyBAQFxcbiddO1xuICB2YXIgb3A7XG4gIC8vIEVzY2FwZSB0aGUgYm9keSBvZiB0aGUgcGF0Y2ggd2l0aCAleHggbm90YXRpb24uXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAodGhpcy5kaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgb3AgPSAnKyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgb3AgPSAnLSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBvcCA9ICcgJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRleHRbeCArIDFdID0gb3AgKyBlbmNvZGVVUkkodGhpcy5kaWZmc1t4XVsxXSkgKyAnXFxuJztcbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKCcnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcbn07XG5cblxuLy8gVGhlIGZvbGxvd2luZyBleHBvcnQgY29kZSB3YXMgYWRkZWQgYnkgQEZvcmJlc0xpbmRlc2F5XG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZfbWF0Y2hfcGF0Y2g7XG5tb2R1bGUuZXhwb3J0c1snZGlmZl9tYXRjaF9wYXRjaCddID0gZGlmZl9tYXRjaF9wYXRjaDtcbm1vZHVsZS5leHBvcnRzWydESUZGX0RFTEVURSddID0gRElGRl9ERUxFVEU7XG5tb2R1bGUuZXhwb3J0c1snRElGRl9JTlNFUlQnXSA9IERJRkZfSU5TRVJUO1xubW9kdWxlLmV4cG9ydHNbJ0RJRkZfRVFVQUwnXSA9IERJRkZfRVFVQUw7Il0sIm5hbWVzIjpbImRpZmZfbWF0Y2hfcGF0Y2giLCJEaWZmX1RpbWVvdXQiLCJEaWZmX0VkaXRDb3N0IiwiTWF0Y2hfVGhyZXNob2xkIiwiTWF0Y2hfRGlzdGFuY2UiLCJQYXRjaF9EZWxldGVUaHJlc2hvbGQiLCJQYXRjaF9NYXJnaW4iLCJNYXRjaF9NYXhCaXRzIiwiRElGRl9ERUxFVEUiLCJESUZGX0lOU0VSVCIsIkRJRkZfRVFVQUwiLCJEaWZmIiwib3AiLCJ0ZXh0IiwicHJvdG90eXBlIiwiZGlmZl9tYWluIiwidGV4dDEiLCJ0ZXh0MiIsIm9wdF9jaGVja2xpbmVzIiwib3B0X2RlYWRsaW5lIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiRGF0ZSIsImdldFRpbWUiLCJkZWFkbGluZSIsIkVycm9yIiwiY2hlY2tsaW5lcyIsImNvbW1vbmxlbmd0aCIsImRpZmZfY29tbW9uUHJlZml4IiwiY29tbW9ucHJlZml4Iiwic3Vic3RyaW5nIiwiZGlmZl9jb21tb25TdWZmaXgiLCJjb21tb25zdWZmaXgiLCJsZW5ndGgiLCJkaWZmcyIsImRpZmZfY29tcHV0ZV8iLCJ1bnNoaWZ0IiwicHVzaCIsImRpZmZfY2xlYW51cE1lcmdlIiwibG9uZ3RleHQiLCJzaG9ydHRleHQiLCJpIiwiaW5kZXhPZiIsImhtIiwiZGlmZl9oYWxmTWF0Y2hfIiwidGV4dDFfYSIsInRleHQxX2IiLCJ0ZXh0Ml9hIiwidGV4dDJfYiIsIm1pZF9jb21tb24iLCJkaWZmc19hIiwiZGlmZnNfYiIsImNvbmNhdCIsImRpZmZfbGluZU1vZGVfIiwiZGlmZl9iaXNlY3RfIiwiYSIsImRpZmZfbGluZXNUb0NoYXJzXyIsImNoYXJzMSIsImNoYXJzMiIsImxpbmVhcnJheSIsImxpbmVBcnJheSIsImRpZmZfY2hhcnNUb0xpbmVzXyIsImRpZmZfY2xlYW51cFNlbWFudGljIiwicG9pbnRlciIsImNvdW50X2RlbGV0ZSIsImNvdW50X2luc2VydCIsInRleHRfZGVsZXRlIiwidGV4dF9pbnNlcnQiLCJzcGxpY2UiLCJzdWJEaWZmIiwiaiIsInBvcCIsInRleHQxX2xlbmd0aCIsInRleHQyX2xlbmd0aCIsIm1heF9kIiwiTWF0aCIsImNlaWwiLCJ2X29mZnNldCIsInZfbGVuZ3RoIiwidjEiLCJBcnJheSIsInYyIiwieCIsImRlbHRhIiwiZnJvbnQiLCJrMXN0YXJ0IiwiazFlbmQiLCJrMnN0YXJ0IiwiazJlbmQiLCJkIiwiazEiLCJrMV9vZmZzZXQiLCJ4MSIsInkxIiwiY2hhckF0IiwiazJfb2Zmc2V0IiwieDIiLCJkaWZmX2Jpc2VjdFNwbGl0XyIsImsyIiwieTIiLCJ5IiwidGV4dDFhIiwidGV4dDJhIiwidGV4dDFiIiwidGV4dDJiIiwiZGlmZnNiIiwibGluZUhhc2giLCJkaWZmX2xpbmVzVG9DaGFyc011bmdlXyIsImNoYXJzIiwibGluZVN0YXJ0IiwibGluZUVuZCIsImxpbmVBcnJheUxlbmd0aCIsImxpbmUiLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1heExpbmVzIiwiY2hhckNvZGVBdCIsImpvaW4iLCJwb2ludGVybWluIiwicG9pbnRlcm1heCIsIm1pbiIsInBvaW50ZXJtaWQiLCJwb2ludGVyc3RhcnQiLCJmbG9vciIsInBvaW50ZXJlbmQiLCJkaWZmX2NvbW1vbk92ZXJsYXBfIiwidGV4dF9sZW5ndGgiLCJiZXN0IiwicGF0dGVybiIsImZvdW5kIiwiZG1wIiwiZGlmZl9oYWxmTWF0Y2hJXyIsInNlZWQiLCJiZXN0X2NvbW1vbiIsImJlc3RfbG9uZ3RleHRfYSIsImJlc3RfbG9uZ3RleHRfYiIsImJlc3Rfc2hvcnR0ZXh0X2EiLCJiZXN0X3Nob3J0dGV4dF9iIiwicHJlZml4TGVuZ3RoIiwic3VmZml4TGVuZ3RoIiwiaG0xIiwiaG0yIiwiY2hhbmdlcyIsImVxdWFsaXRpZXMiLCJlcXVhbGl0aWVzTGVuZ3RoIiwibGFzdEVxdWFsaXR5IiwibGVuZ3RoX2luc2VydGlvbnMxIiwibGVuZ3RoX2RlbGV0aW9uczEiLCJsZW5ndGhfaW5zZXJ0aW9uczIiLCJsZW5ndGhfZGVsZXRpb25zMiIsIm1heCIsImRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MiLCJkZWxldGlvbiIsImluc2VydGlvbiIsIm92ZXJsYXBfbGVuZ3RoMSIsIm92ZXJsYXBfbGVuZ3RoMiIsImRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfIiwib25lIiwidHdvIiwiY2hhcjEiLCJjaGFyMiIsIm5vbkFscGhhTnVtZXJpYzEiLCJtYXRjaCIsIm5vbkFscGhhTnVtZXJpY1JlZ2V4XyIsIm5vbkFscGhhTnVtZXJpYzIiLCJ3aGl0ZXNwYWNlMSIsIndoaXRlc3BhY2VSZWdleF8iLCJ3aGl0ZXNwYWNlMiIsImxpbmVCcmVhazEiLCJsaW5lYnJlYWtSZWdleF8iLCJsaW5lQnJlYWsyIiwiYmxhbmtMaW5lMSIsImJsYW5rbGluZUVuZFJlZ2V4XyIsImJsYW5rTGluZTIiLCJibGFua2xpbmVTdGFydFJlZ2V4XyIsImVxdWFsaXR5MSIsImVkaXQiLCJlcXVhbGl0eTIiLCJjb21tb25PZmZzZXQiLCJjb21tb25TdHJpbmciLCJiZXN0RXF1YWxpdHkxIiwiYmVzdEVkaXQiLCJiZXN0RXF1YWxpdHkyIiwiYmVzdFNjb3JlIiwic2NvcmUiLCJkaWZmX2NsZWFudXBFZmZpY2llbmN5IiwicHJlX2lucyIsInByZV9kZWwiLCJwb3N0X2lucyIsInBvc3RfZGVsIiwiZGlmZl94SW5kZXgiLCJsb2MiLCJsYXN0X2NoYXJzMSIsImxhc3RfY2hhcnMyIiwiZGlmZl9wcmV0dHlIdG1sIiwiaHRtbCIsInBhdHRlcm5fYW1wIiwicGF0dGVybl9sdCIsInBhdHRlcm5fZ3QiLCJwYXR0ZXJuX3BhcmEiLCJkYXRhIiwicmVwbGFjZSIsImRpZmZfdGV4dDEiLCJkaWZmX3RleHQyIiwiZGlmZl9sZXZlbnNodGVpbiIsImxldmVuc2h0ZWluIiwiaW5zZXJ0aW9ucyIsImRlbGV0aW9ucyIsImRpZmZfdG9EZWx0YSIsImVuY29kZVVSSSIsImRpZmZfZnJvbURlbHRhIiwiZGlmZnNMZW5ndGgiLCJ0b2tlbnMiLCJzcGxpdCIsInBhcmFtIiwiZGVjb2RlVVJJIiwiZXgiLCJuIiwicGFyc2VJbnQiLCJpc05hTiIsIm1hdGNoX21haW4iLCJtYXRjaF9iaXRhcF8iLCJzIiwibWF0Y2hfYWxwaGFiZXRfIiwibWF0Y2hfYml0YXBTY29yZV8iLCJlIiwiYWNjdXJhY3kiLCJwcm94aW1pdHkiLCJhYnMiLCJzY29yZV90aHJlc2hvbGQiLCJiZXN0X2xvYyIsImxhc3RJbmRleE9mIiwibWF0Y2htYXNrIiwiYmluX21pbiIsImJpbl9taWQiLCJiaW5fbWF4IiwibGFzdF9yZCIsInN0YXJ0IiwiZmluaXNoIiwicmQiLCJjaGFyTWF0Y2giLCJwYXRjaF9hZGRDb250ZXh0XyIsInBhdGNoIiwic3RhcnQyIiwibGVuZ3RoMSIsInBhZGRpbmciLCJwcmVmaXgiLCJzdWZmaXgiLCJzdGFydDEiLCJsZW5ndGgyIiwicGF0Y2hfbWFrZSIsIm9wdF9iIiwib3B0X2MiLCJwYXRjaGVzIiwicGF0Y2hfb2JqIiwicGF0Y2hEaWZmTGVuZ3RoIiwiY2hhcl9jb3VudDEiLCJjaGFyX2NvdW50MiIsInByZXBhdGNoX3RleHQiLCJwb3N0cGF0Y2hfdGV4dCIsImRpZmZfdHlwZSIsImRpZmZfdGV4dCIsInBhdGNoX2RlZXBDb3B5IiwicGF0Y2hlc0NvcHkiLCJwYXRjaENvcHkiLCJwYXRjaF9hcHBseSIsIm51bGxQYWRkaW5nIiwicGF0Y2hfYWRkUGFkZGluZyIsInBhdGNoX3NwbGl0TWF4IiwicmVzdWx0cyIsImV4cGVjdGVkX2xvYyIsInN0YXJ0X2xvYyIsImVuZF9sb2MiLCJpbmRleDEiLCJpbmRleDIiLCJtb2QiLCJwYWRkaW5nTGVuZ3RoIiwiZXh0cmFMZW5ndGgiLCJwYXRjaF9zaXplIiwiYmlncGF0Y2giLCJwcmVjb250ZXh0IiwiZW1wdHkiLCJzaGlmdCIsInBvc3Rjb250ZXh0IiwicGF0Y2hfdG9UZXh0IiwicGF0Y2hfZnJvbVRleHQiLCJ0ZXh0bGluZSIsInRleHRQb2ludGVyIiwicGF0Y2hIZWFkZXIiLCJtIiwic2lnbiIsInRvU3RyaW5nIiwiY29vcmRzMSIsImNvb3JkczIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/diff-match-patch/index.js\n");

/***/ })

};
;